<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32 AI Rotation & ROI Tool</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 20px;
            background-color: #f0f2f5;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            gap: 20px;
        }

        .main-panel {
            flex: 2;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .sidebar {
            flex: 1;
            min-width: 350px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        h1,
        h2,
        h3 {
            margin-top: 0;
            color: #2c3e50;
        }

        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 20px;
            align-items: center;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
        }

        .btn-primary {
            background-color: #3498db;
            color: white;
        }

        .btn-primary:hover {
            background-color: #2980b9;
        }

        .btn-danger {
            background-color: #e74c3c;
            color: white;
        }

        .btn-secondary {
            background-color: #95a5a6;
            color: white;
        }

        .btn.active {
            ring: 2px solid #2c3e50;
            transform: translateY(1px);
        }

        .canvas-wrapper {
            position: relative;
            overflow: auto;
            max-height: 80vh;
            border: 1px solid #ddd;
            background-image: repeating-linear-gradient(45deg, #eee 25%, transparent 25%, transparent 75%, #eee 75%, #eee), repeating-linear-gradient(45deg, #eee 25%, #fff 25%, #fff 75%, #eee 75%, #eee);
            background-position: 0 0, 10px 10px;
            background-size: 20px 20px;
        }

        canvas {
            display: block;
            cursor: crosshair;
        }

        textarea {
            width: 100%;
            height: 300px;
            font-family: monospace;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            resize: vertical;
        }

        .status-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.9em;
            margin-left: 10px;
        }

        .status-mode {
            background: #e8f6f3;
            color: #1abc9c;
            border: 1px solid #1abc9c;
        }

        .help-text {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 10px;
        }

        .mode-toggles {
            display: flex;
            margin-bottom: 15px;
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid #bdc3c7;
        }

        .mode-btn {
            flex: 1;
            padding: 10px;
            border: none;
            background: #f8f9fa;
            cursor: pointer;
            font-weight: 500;
        }

        .mode-btn.active {
            background: #3498db;
            color: white;
        }

        .mode-btn:not(:last-child) {
            border-right: 1px solid #bdc3c7;
        }

        .legend {
            margin-top: 10px;
            font-size: 0.85em;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-bottom: 5px;
        }

        .color-box {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="main-panel">
            <h1>ESP32 AI Configuration Tool</h1>

            <div class="controls">
                <input type="file" id="imageInput" accept="image/*" style="display: none;">
                <button class="btn btn-primary" onclick="document.getElementById('imageInput').click()">ðŸ“‚ Load
                    Image</button>

                <div
                    style="border-left: 1px solid #ddd; padding-left: 10px; margin-left: 10px; display: flex; gap: 5px; align-items: center;">
                    <span>Sensor:</span>
                    <div class="dropdown" style="position: relative; display: inline-block;">
                        <button class="btn btn-secondary"
                            onclick="document.getElementById('resDropdown').style.display='block'"
                            id="sensor-res-label">OV2640 UXGA (1600x1200)</button>
                        <div id="resDropdown"
                            style="display: none; position: absolute; background-color: #f9f9f9; min-width: 160px; box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2); z-index: 1;">
                            <a href="#" style="color: black; padding: 12px 16px; text-decoration: none; display: block;"
                                onclick="setSensorRes(1600, 1200, 'OV2640 UXGA (1600x1200)'); document.getElementById('resDropdown').style.display='none'; return false;">UXGA
                                (1600x1200)</a>
                            <a href="#" style="color: black; padding: 12px 16px; text-decoration: none; display: block;"
                                onclick="setSensorRes(1280, 1024, 'OV2640 SXGA (1280x1024)'); document.getElementById('resDropdown').style.display='none'; return false;">SXGA
                                (1280x1024)</a>
                            <a href="#" style="color: black; padding: 12px 16px; text-decoration: none; display: block;"
                                onclick="setSensorRes(1024, 768, 'OV2640 XGA (1024x768)'); document.getElementById('resDropdown').style.display='none'; return false;">XGA
                                (1024x768)</a>
                            <a href="#" style="color: black; padding: 12px 16px; text-decoration: none; display: block;"
                                onclick="setSensorRes(800, 600, 'OV2640 SVGA (800x600)'); document.getElementById('resDropdown').style.display='none'; return false;">SVGA
                                (800x600)</a>
                            <a href="#" style="color: black; padding: 12px 16px; text-decoration: none; display: block;"
                                onclick="setSensorRes(640, 480, 'OV2640 VGA (640x480)'); document.getElementById('resDropdown').style.display='none'; return false;">VGA
                                (640x480)</a>
                            <a href="#" style="color: black; padding: 12px 16px; text-decoration: none; display: block;"
                                onclick="setSensorRes(1632, 1220, 'Max (1632x1220)'); document.getElementById('resDropdown').style.display='none'; return false;">Max
                                (1632x1220)</a>
                        </div>
                    </div>
                </div>

                <div
                    style="border-left: 1px solid #ddd; padding-left: 10px; margin-left: 10px; display: flex; gap: 5px; align-items: center;">
                    <span>Rotation:</span>
                    <button class="btn btn-secondary" onclick="setRotation(0)">0Â°</button>
                    <button class="btn btn-secondary" onclick="setRotation(90)">90Â°</button>
                    <button class="btn btn-secondary" onclick="setRotation(180)">180Â°</button>
                    <button class="btn btn-secondary" onclick="setRotation(270)">270Â°</button>
                </div>

                <div
                    style="border-left: 1px solid #ddd; padding-left: 10px; margin-left: 10px; display: flex; gap: 5px; align-items: center;">
                    <input type="checkbox" id="force43" onchange="state.force43 = this.checked; generateOutput()">
                    <label for="force43" style="cursor: pointer; user-select: none;">Force 4:3 Ratio</label>
                </div>
            </div>

            <div class="mode-toggles">
                <button class="mode-btn active" onclick="setMode('roi')" id="btn-mode-roi">1. Set Camera ROI</button>
                <button class="mode-btn" onclick="setMode('digits')" id="btn-mode-digits">2. Set Digit Zones</button>
            </div>

            <p class="help-text" id="help-text">Select "Load Image" to start. Then draw the Camera ROI (Blue) to define
                the active window.</p>

            <div class="canvas-wrapper">
                <canvas id="canvas"></canvas>
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="color-box" style="background: rgba(52, 152, 219, 0.3); border: 2px solid #3498db;">
                    </div> Camera ROI (Hardware Window)
                </div>
                <div class="legend-item">
                    <div class="color-box" style="background: rgba(46, 204, 113, 0.3); border: 2px solid #2ecc71;">
                    </div> Digit Zones (Software Crop)
                </div>
            </div>
        </div>

        <div class="sidebar">
            <div class="card">
                <h3>Target Sensor ROI</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px;">
                    <div>
                        <label>Off_X:</label> <input type="number" id="manual_x" onchange="updateROIFromInput()"
                            style="width: 50px;">
                    </div>
                    <div>
                        <label>Off_Y:</label> <input type="number" id="manual_y" onchange="updateROIFromInput()"
                            style="width: 50px;">
                    </div>
                    <div>
                        <label>Width:</label> <input type="number" id="manual_w" onchange="updateROIFromInput()"
                            style="width: 50px;">
                    </div>
                    <div>
                        <label>Height:</label> <input type="number" id="manual_h" onchange="updateROIFromInput()"
                            style="width: 50px;">
                    </div>
                </div>
            </div>

            <div class="card">
                <h3>Configuration Output</h3>
                <textarea id="output" readonly></textarea>
                <button class="btn btn-primary" style="width: 100%; margin-top: 10px;" onclick="copyOutput()">ðŸ“‹ Copy to
                    Clipboard</button>
            </div>

            <div class="card">
                <h3>Actions</h3>
                <button class="btn btn-danger" style="width: 100%; margin-bottom: 10px;" onclick="resetCurrent()">Clear
                    Current Items</button>
                <button class="btn btn-danger" style="width: 100%;" onclick="resetAll()">Reset All</button>
            </div>
        </div>
    </div>

    <script>
        // State
        let state = {
            image: null,
            rotation: 0, // 0, 90, 180, 270
            mode: 'roi', // 'roi', 'digits'
            roi: null, // {x, y, w, h} in ROTATED coordinates
            digits: [], // Array of {x, y, w, h} in ROTATED coordinates relative to 0,0 of canvas
            isDrawing: false,
            startPos: null,
            sensorRes: { w: 1600, h: 1200, name: "OV2640 UXGA (1600x1200)" },
            force43: false
        };

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Init
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseleave', stopDrawing);
        document.getElementById('imageInput').addEventListener('change', handleImageUpload);

        function handleImageUpload(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    state.image = img;
                    state.roi = null;
                    state.digits = [];
                    updateImageInfo();
                    updateCanvas();
                    generateOutput();
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }

        function updateImageInfo() {
            const infoDiv = document.getElementById('image-info') || createImageInfoDiv();
            if (state.image) {
                infoDiv.textContent = `Image Size: ${state.image.width} x ${state.image.height}`;
            } else {
                infoDiv.textContent = '';
            }
        }

        function setSensorRes(w, h, name) {
            state.sensorRes = { w, h, name };
            document.getElementById('sensor-res-label').textContent = name;
            generateOutput();
        }

        function createImageInfoDiv() {
            const div = document.createElement('div');
            div.id = 'image-info';
            div.style.marginLeft = '10px';
            div.style.fontWeight = 'bold';
            div.style.color = '#555';
            // Insert after file input controls
            const controls = document.querySelector('.controls');
            controls.appendChild(div);
            return div;
        }

        function setRotation(deg) {
            state.rotation = deg;
            // When rotation changes, ROI and Digits are invalid visually unless we map them.
            // For simplicity in this tool, we CLEAR them to avoid confusion, 
            // as usually you set rotation first then draw.
            if (confirm("Changing rotation will clear current regions. Continue?")) {
                state.roi = null;
                state.digits = [];
                updateCanvas();
                generateOutput();
            }
        }

        function setMode(mode) {
            state.mode = mode;
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('btn-mode-' + mode).classList.add('active');

            const help = document.getElementById('help-text');
            if (mode === 'roi') help.textContent = "Draw a rectangle to define the Camera Window (Blue). This limits what the ESP32 processes.";
            else help.textContent = "Draw boxes around each digit (Green) INSIDE the Blue ROI.";

            updateCanvas();
        }

        function getTransformedDimensions() {
            if (!state.image) return { w: 800, h: 600 };
            if (state.rotation === 0 || state.rotation === 180) {
                return { w: state.image.width, h: state.image.height };
            } else {
                return { w: state.image.height, h: state.image.width };
            }
        }

        function updateCanvas() {
            const dims = getTransformedDimensions();
            canvas.width = dims.w;
            canvas.height = dims.h;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (!state.image) {
                ctx.fillStyle = '#ccc';
                ctx.textAlign = 'center';
                ctx.fillText('No Image Loaded', canvas.width / 2, canvas.height / 2);
                return;
            }

            // Draw Rotated Image
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.rotate(state.rotation * Math.PI / 180);
            ctx.drawImage(state.image, -state.image.width / 2, -state.image.height / 2);
            ctx.restore();

            // Draw ROI
            if (state.roi) {
                ctx.strokeStyle = '#3498db';
                ctx.lineWidth = 3;
                ctx.fillStyle = 'rgba(52, 152, 219, 0.2)';
                ctx.fillRect(state.roi.x, state.roi.y, state.roi.w, state.roi.h);
                ctx.strokeRect(state.roi.x, state.roi.y, state.roi.w, state.roi.h);

                // Dim outside ROI
                /*
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.beginPath();
                ctx.rect(0, 0, canvas.width, canvas.height);
                ctx.rect(state.roi.x, state.roi.y, state.roi.w, state.roi.h);
                ctx.fill('evenodd');
                */

                // Sync Manual Inputs to Visual ROI
                if (!state.isManualUpdate) {
                    document.getElementById('manual_x').value = state.roi.x;
                    document.getElementById('manual_y').value = state.roi.y;
                    document.getElementById('manual_w').value = state.roi.w;
                    document.getElementById('manual_h').value = state.roi.h;
                }
            } else {
                // Clear inputs if no ROI
                if (!state.isManualUpdate) {
                    document.getElementById('manual_x').value = "";
                    document.getElementById('manual_y').value = "";
                    document.getElementById('manual_w').value = "";
                    document.getElementById('manual_h').value = "";
                }
            }

            // Draw Digits
            state.digits.forEach((d, i) => {
                ctx.strokeStyle = '#2ecc71';
                ctx.lineWidth = 2;
                ctx.fillStyle = 'rgba(46, 204, 113, 0.3)';
                ctx.fillRect(d.x, d.y, d.w, d.h);
                ctx.strokeRect(d.x, d.y, d.w, d.h);

                ctx.fillStyle = '#fff';
                ctx.font = '12px sans-serif';
                ctx.globalAlpha = 1.0;
                ctx.fillText(`#${i + 1}`, d.x + 2, d.y + 12);
            });
        }

        // Coordinate Mapping: Rotated (Canvas) -> Original (Sensor)
        function mapToOriginal(x, y, w, h) {
            const W = state.image.width;
            const H = state.image.height;
            let ox, oy, ow, oh;

            // Note: Standard image rotation usually is center-based
            // 0: x,y
            // 90 (CW): x'=H-y, y'=x  (Mapping FROM original TO rotated)
            // We need FROM rotated TO original

            // Rotated Dims
            const RW = (state.rotation % 180 === 0) ? W : H;
            const RH = (state.rotation % 180 === 0) ? H : W;

            switch (state.rotation) {
                case 0:
                    ox = x; oy = y; ow = w; oh = h;
                    break;
                case 90:
                    // new x is old y, new y is old (W-x)
                    // Inverse: old x = y (rotated), old y = RW - x (rotated) - h (rotated-orient) ?
                    // Let's think corners.
                    // Rotated (x,y) -> Original?
                    // 90 CW: Top Right of Orig becomes Bottom Right of Rotated? No.
                    // 90 CW: 
                    // (0,0) orig -> (H, 0) rot? NO.
                    // (0,0) orig -> (RH, 0) rot?
                    // Let's use standard transform logic.
                    // cw90: (x,y) -> (H-y, x) (assuming 0-indexed)
                    // Inverse cw90 is ccw90: (x,y) -> (y, W-x)

                    // But we have a rectangle.
                    // Rot Rect (x,y,w,h).
                    // TL(x,y) -> (y, W-x).
                    // TR(x+w,y) -> (y, W-(x+w)).
                    // BL(x,y+h) -> (y+h, W-x).
                    // We need bounding box in original space.

                    // CCW 90 of (x,y) in RWxRH space:
                    // ox = y
                    // oy = RW - x // (RW is H of original) ... wait.

                    // Let's trace simpler:
                    // Rotated 90 (CW). Width=H_orig, Height=W_orig.
                    // Point P_rot(u, v).
                    // P_orig(v, H_rot - u).  where H_rot is Width_orig.

                    // Example: Rot(10, 10). H_rot=100.
                    // Orig(10, 100-10) = (10, 90).
                    // Let's verify 90CW of (10,90). (100-90, 10) = (10,10). Correct.

                    // So: ox = y; oy = (RW) - (x + w); 
                    // ow = h; oh = w;
                    ox = y;
                    oy = RW - (x + w);
                    ow = h;
                    oh = w;
                    break;

                case 180:
                    // (x,y) -> (W-x, H-y)
                    // Inverse is same.
                    ox = RW - (x + w);
                    oy = RH - (y + h);
                    ow = w;
                    oh = h;
                    break;

                case 270: // 90 CCW
                    // (x,y) -> (y, W-x)
                    // Inverse is 90 CW: (x,y) -> (RH-y, x)
                    ox = RH - (y + h);
                    oy = x;
                    ow = h;
                    oh = w;
                    break;
            }

            // Ensure integer
            return {
                x: Math.round(ox),
                y: Math.round(oy),
                w: Math.round(ow),
                h: Math.round(oh)
            };
        }

        function snapTo4(val) {
            return Math.round(val / 4) * 4;
        }

        function generateOutput() {
            const ta = document.getElementById('output');
            if (!state.image) { ta.value = ""; return; }

            let lines = [];

            // Image Dimensions (Unrotated - how it was loaded)
            const img_w = state.image.width;
            const img_h = state.image.height;

            // Sensor Dimensions
            let sensor_w = state.sensorRes.w;
            let sensor_h = state.sensorRes.h;

            // Calculate Scale Factor (Sensor / Visual)
            // Assumes image represents the full FOV of the sensor, just resized.
            let scale_x = sensor_w / img_w;
            let scale_y = sensor_h / img_h;

            let anisotropic = Math.abs(scale_x - scale_y) > 0.1;

            lines.push(`# Sensor: ${state.sensorRes.name}`);
            lines.push(`# Image: ${img_w}x${img_h}`);
            lines.push(`# Scale: ${scale_x.toFixed(2)}x (Horizontal)`);
            if (anisotropic) lines.push(`# WARNING: Anisotropic scaling detected! (${scale_x.toFixed(2)} vs ${scale_y.toFixed(2)})`);
            lines.push(`rotation: ${state.rotation}`);

            if (state.roi) {
                // 1. Map Visual ROI -> Unrotated Image Coordinates (0-img_w)
                const visROI = mapToOriginal(state.roi.x, state.roi.y, state.roi.w, state.roi.h);

                // 2. Scale to Sensor Coordinates
                let raw_x = visROI.x * scale_x;
                let raw_y = visROI.y * scale_y;
                let raw_w = visROI.w * scale_x;
                let raw_h = visROI.h * scale_y;

                let off_x, off_y, w, h;

                if (state.force43) {
                    // Force 4:3 Ratio logic (also adhering to Multiple of 4)
                    // W must be multiple of 16 (4*4), H multiple of 12 (3*4) to be simple 4:3 and %4.
                    let nw = raw_w / 16;
                    let nh = raw_h / 12;
                    let n = Math.max(1, Math.round(Math.max(nw, nh)));

                    let target_w = n * 16;
                    let target_h = n * 12; // 4:3 ratio

                    // Center it
                    let cx = raw_x + raw_w / 2;
                    let cy = raw_y + raw_h / 2;

                    let new_x = cx - target_w / 2;
                    let new_y = cy - target_h / 2;

                    off_x = snapTo4(Math.max(0, new_x));
                    off_y = snapTo4(Math.max(0, new_y));
                    w = target_w;
                    h = target_h;

                    lines.push(`# Enforcement: 4:3 Aspect Ratio (W/H = ${w}/${h})`);
                } else {
                    // 3. Snap to 4 (Flexible Ratio)
                    off_x = snapTo4(Math.max(0, raw_x));
                    off_y = snapTo4(Math.max(0, raw_y));
                    w = snapTo4(Math.max(4, raw_w));
                    h = snapTo4(Math.max(4, raw_h));
                }

                // Explanatory Comments for Swapped Dims
                let comment_w = "# multiple of 4";
                let comment_h = "# multiple of 4";

                if (state.rotation === 90 || state.rotation === 270) {
                    comment_w += " (Visual Height)";
                    comment_h += " (Visual Width)";
                }

                // 4. Bounds Check (Sensor Space)
                if (off_x + w > sensor_w) lines.push(`# WARNING: ROI width exceeds sensor bounds!`);
                if (off_y + h > sensor_h) lines.push(`# WARNING: ROI height exceeds sensor bounds!`);

                lines.push(`camera_window:`);
                lines.push(`  offset_x: ${off_x} # multiple of 4`);
                lines.push(`  offset_y: ${off_y} # multiple of 4`);
                lines.push(`  width: ${w} ${comment_w}`);
                lines.push(`  height: ${h} ${comment_h}`);

                // Digits
                if (state.digits.length > 0) {
                    const zones = state.digits.map(d_vis => {
                        // 1. Visual -> Sensor Global (Original Unrotated)
                        // Then Scale to Sensor Space
                        const sensor_g = mapToOriginal(d_vis.x, d_vis.y, d_vis.w, d_vis.h);
                        const d_sensor_x = sensor_g.x * scale_x;
                        const d_sensor_y = sensor_g.y * scale_y;
                        const d_sensor_w = sensor_g.w * scale_x;
                        const d_sensor_h = sensor_g.h * scale_y;

                        // 2. Relativize to Snapped Window (in Sensor Space)
                        let rel_x = d_sensor_x - off_x;
                        let rel_y = d_sensor_y - off_y;

                        // 3. Transform to Configured Rotation Space (Final Output)
                        // The output image will be the Window (w x h).
                        // Rotation applies to this window.

                        let out_w = (state.rotation % 180 === 0) ? w : h;
                        let out_h = (state.rotation % 180 === 0) ? h : w;

                        let fin_x, fin_y, fin_w, fin_h;

                        switch (state.rotation) {
                            case 0:
                                fin_x = rel_x;
                                fin_y = rel_y;
                                fin_w = d_sensor_w;
                                fin_h = d_sensor_h;
                                break;
                            case 90:
                                // CW 90: (x,y) -> (H-y-h, x)
                                fin_x = out_w - rel_y - d_sensor_h;
                                fin_y = rel_x;
                                fin_w = d_sensor_h;
                                fin_h = d_sensor_w;
                                break;
                            case 180:
                                // (x,y) -> (W-x-w, H-y-h)
                                fin_x = out_w - rel_x - d_sensor_w;
                                fin_y = out_h - rel_y - d_sensor_h;
                                fin_w = d_sensor_w;
                                fin_h = d_sensor_h;
                                break;
                            case 270:
                                // CCW 90
                                fin_x = rel_y;
                                fin_y = out_h - rel_x - d_sensor_w;
                                fin_w = d_sensor_h;
                                fin_h = d_sensor_w;
                                break;
                        }

                        // NOTE: If actual output is resized (e.g. window 240x680 -> output 480x640), 
                        // these pixel values will be wrong for the resized image.
                        // But precise crop zones usually require matching window to resolution.

                        return [
                            Math.round(fin_x),
                            Math.round(fin_y),
                            Math.round(fin_x + fin_w),
                            Math.round(fin_y + fin_h)
                        ];
                    });

                    // Single-line JSON string format
                    const jsonStr = JSON.stringify(zones);
                    lines.push(``);
                    lines.push(`# Crop Zones (Sensor Space - Relative to Window)`);
                    lines.push(`initial_value: '"${jsonStr}"'`);
                }
            }

            ta.value = lines.join('\n');
        }

        // Interaction
        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (e.clientX - rect.left),
                y: (e.clientY - rect.top)
            };
        }

        function startDrawing(e) {
            if (!state.image) return;
            state.isDrawing = true;
            state.startPos = getMousePos(e);
        }

        function draw(e) {
            if (!state.isDrawing) return;
            const pos = getMousePos(e);
            const w = pos.x - state.startPos.x;
            const h = pos.y - state.startPos.y;

            updateCanvas(); // Clear old partial rect

            // Draw scratch rect
            ctx.strokeStyle = state.mode === 'roi' ? '#3498db' : '#2ecc71';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(state.startPos.x, state.startPos.y, w, h);
            ctx.setLineDash([]);
        }

        function stopDrawing(e) {
            if (!state.isDrawing) return;
            state.isDrawing = false;
            const pos = getMousePos(e);

            // Normalize Rect
            let x = Math.min(state.startPos.x, pos.x);
            let y = Math.min(state.startPos.y, pos.y);
            let w = Math.abs(pos.x - state.startPos.x);
            let h = Math.abs(pos.y - state.startPos.y);

            // Snap/Min size
            if (w < 4 || h < 4) return;

            if (state.mode === 'roi') {
                state.roi = { x, y, w, h };
                state.digits = []; // Reset digits if ROI changes
            } else {
                if (!state.roi) {
                    alert("Please set the Camera ROI first.");
                    return;
                }

                // Clip/Ensure inside ROI
                // Simple check for now
                if (x < state.roi.x || y < state.roi.y ||
                    (x + w) > (state.roi.x + state.roi.w) ||
                    (y + h) > (state.roi.y + state.roi.h)) {
                    if (!confirm("Warning: Zone is outside ROI. Keep it?")) return;
                }

                state.digits.push({ x, y, w, h });
            }

            updateCanvas();
            generateOutput();
        }

        function resetCurrent() {
            if (state.mode === 'roi') state.roi = null;
            if (state.mode === 'digits') state.digits.pop(); // Undo last
            updateCanvas();
            generateOutput();
        }

        function resetAll() {
            state.roi = null;
            state.digits = [];
            updateCanvas();
            generateOutput();
        }

        function copyOutput() {
            const copyText = document.getElementById("output");
            copyText.select();
            document.execCommand("copy");
            alert("Copied to clipboard");
        }
        // Coordinate Mapping: Original (Sensor) -> Rotated (Canvas) - INVERSE
        function mapFromOriginal(ox, oy, ow, oh) {
            const W = state.image.width;
            const H = state.image.height;
            let x, y, w, h;

            // Rotated Dims (Canvas Dims)
            const RW = (state.rotation % 180 === 0) ? W : H;
            const RH = (state.rotation % 180 === 0) ? H : W;

            switch (state.rotation) {
                case 0:
                    x = ox; y = oy; w = ow; h = oh;
                    break;
                case 90:
                    // Inverse 90 CW
                    // x = RW - oy - oh
                    // y = ox
                    // w = oh
                    // h = ow
                    x = RW - oy - oh;
                    y = ox;
                    w = oh;
                    h = ow;
                    break;
                case 180:
                    // Inverse 180
                    // x = RW - ox - ow
                    // y = RH - oy - oh
                    x = RW - ox - ow;
                    y = RH - oy - oh;
                    w = ow;
                    h = oh;
                    break;
                case 270: // 90 CCW
                    // Inverse 270 (which is 90 CW from Rotated perspective)
                    // x = oy
                    // y = RH - ox - w (wait, h?)
                    // From mapToOrignial 270: ox = RH - (y+h). -> ox = RH - y - h -> y = RH - ox - h. Correct.
                    x = oy;
                    y = RH - ox - ow; // FIXED: Visual Y depends on Visual Height (Sensor Width)
                    w = oh;
                    h = ow;
                    break;
            }

            return { x, y, w, h };
        }

        function updateROIFromInput() {
            if (!state.image) return;
            // Inputs are SENSOR coordinates
            const off_x = parseInt(document.getElementById('manual_x').value) || 0;
            const off_y = parseInt(document.getElementById('manual_y').value) || 0;
            const w_in = parseInt(document.getElementById('manual_w').value) || 100;
            const h_in = parseInt(document.getElementById('manual_h').value) || 100;

            // 1. Unscale: Sensor -> Unrotated Image Space
            const img_w = state.image.width;
            const img_h = state.image.height;
            const sensor_w = state.sensorRes.w;
            const sensor_h = state.sensorRes.h;

            const scale_x = sensor_w / img_w;
            const scale_y = sensor_h / img_h;

            let ox = off_x / scale_x;
            let oy = off_y / scale_y;
            let ow = w_in / scale_x;
            let oh = h_in / scale_y;

            // 2. Unmap: Unrotated Image Space -> Rotated Visual Space
            const vis = mapFromOriginal(ox, oy, ow, oh);

            // 3. Set State (Visual)
            state.roi = {
                x: Math.round(vis.x),
                y: Math.round(vis.y),
                w: Math.round(vis.w),
                h: Math.round(vis.h)
            };

            state.isManualUpdate = true; // prevent loop
            updateCanvas();
            generateOutput(); // This will snap values and update inputs again, but that's okay (auto-correction)
            state.isManualUpdate = false;
        }

        // Mouse Events
        function startDrawing(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            state.startPos = { x, y };
            state.isDrawing = true;
        }

        function draw(e) {
            if (!state.isDrawing) return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const w = x - state.startPos.x;
            const h = y - state.startPos.y;

            if (state.mode === 'roi') {
                // Ensure Positive WH
                let rx = state.startPos.x;
                let ry = state.startPos.y;
                let rw = w;
                let rh = h;

                if (rw < 0) { rx += rw; rw = Math.abs(rw); }
                if (rh < 0) { ry += rh; rh = Math.abs(rh); }

                state.roi = { x: rx, y: ry, w: rw, h: rh };
            } else if (state.mode === 'digits') {
                // Don't update digits live, just visualize current drag?
                // For now, let's just use ROI visual
            }
            updateCanvas();
        }

        function stopDrawing(e) {
            if (!state.isDrawing) return;
            state.isDrawing = false;

            // If mode was digits and we finished a rect, add it
            if (state.mode === 'digits') {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                let rw = x - state.startPos.x;
                let rh = y - state.startPos.y;
                let rx = state.startPos.x;
                let ry = state.startPos.y;

                if (rw < 0) { rx += rw; rw = Math.abs(rw); }
                if (rh < 0) { ry += rh; rh = Math.abs(rh); }

                if (rw > 5 && rh > 5) {
                    state.digits.push({ x: rx, y: ry, w: rw, h: rh });
                }
            }

            generateOutput();
        }

    </script>
</body>

</html>