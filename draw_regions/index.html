<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32 AI Rotation & ROI Tool v3</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 20px;
            background-color: #f0f2f5;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            gap: 20px;
        }

        .main-panel {
            flex: 2;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .sidebar {
            flex: 1;
            min-width: 350px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        h1,
        h2,
        h3 {
            margin-top: 0;
            color: #2c3e50;
        }

        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 20px;
            align-items: center;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
        }

        .btn-primary {
            background-color: #3498db;
            color: white;
        }

        .btn-primary:hover {
            background-color: #2980b9;
        }

        .btn-danger {
            background-color: #e74c3c;
            color: white;
        }

        .btn-secondary {
            background-color: #95a5a6;
            color: white;
        }

        .btn.active {
            box-shadow: 0 0 0 2px #2c3e50;
            transform: translateY(1px);
        }

        .canvas-wrapper {
            position: relative;
            overflow: auto;
            max-height: 80vh;
            border: 1px solid #ddd;
            background-image: repeating-linear-gradient(45deg, #eee 25%, transparent 25%, transparent 75%, #eee 75%, #eee), repeating-linear-gradient(45deg, #eee 25%, #fff 25%, #fff 75%, #eee 75%, #eee);
            background-position: 0 0, 10px 10px;
            background-size: 20px 20px;
        }

        canvas {
            display: block;
            cursor: crosshair;
        }

        textarea {
            width: 100%;
            height: 300px;
            font-family: monospace;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            resize: vertical;
        }

        .status-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.9em;
            margin-left: 10px;
        }

        .status-mode {
            background: #e8f6f3;
            color: #1abc9c;
            border: 1px solid #1abc9c;
        }

        .help-text {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 10px;
        }

        .mode-toggles {
            display: flex;
            margin-bottom: 15px;
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid #bdc3c7;
        }

        .mode-btn {
            flex: 1;
            padding: 10px;
            border: none;
            background: #f8f9fa;
            cursor: pointer;
            font-weight: 500;
        }

        .mode-btn.active {
            background: #3498db;
            color: white;
        }

        .mode-btn:not(:last-child) {
            border-right: 1px solid #bdc3c7;
        }

        .legend {
            margin-top: 10px;
            font-size: 0.85em;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-bottom: 5px;
        }

        .color-box {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="main-panel">
            <h1>ESP32 AI Configuration Tool</h1>

            <div class="controls">
                <input type="file" id="imageInput" accept="image/*" style="display: none;">
                <button class="btn btn-primary" onclick="document.getElementById('imageInput').click()">ðŸ“‚ Load
                    Image</button>


            </div>

            <div class="mode-toggles">
                <button class="mode-btn active" onclick="setMode('roi')" id="btn-mode-roi">1. Set Camera ROI
                    (Optional)</button>
                <button class="mode-btn" onclick="setMode('digits')" id="btn-mode-digits">2. Set Digit Zones</button>
                <button class="mode-btn" onclick="setMode('analog')" id="btn-mode-analog">3. Set Analog Dials</button>
            </div>

            <p class="help-text" id="help-text">Select "Load Image" to start. Then draw the Camera ROI (Blue) to define
                the active window.</p>

            <div class="canvas-wrapper">
                <canvas id="canvas"></canvas>
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="color-box" style="background: rgba(52, 152, 219, 0.3); border: 2px solid #3498db;">
                    </div> Camera ROI (Hardware Window)
                </div>
                <div class="legend-item">
                    <div class="color-box" style="background: rgba(46, 204, 113, 0.3); border: 2px solid #2ecc71;">
                    </div> Digit Zones (Software Crop)
                </div>
                <div class="legend-item">
                    <div class="color-box" style="background: rgba(243, 156, 18, 0.3); border: 2px solid #f39c12;">
                    </div> Analog Dials (Software Crop)
                </div>
            </div>

            <div class="card" style="margin-top: 20px;">
                <h3>Configuration Output</h3>
                <textarea id="output" readonly style="height: 200px;"></textarea>
                <button class="btn btn-primary" style="width: 100%; margin-top: 10px;" onclick="copyOutput()">ðŸ“‹ Copy to
                    Clipboard</button>
            </div>
        </div>

        <div class="sidebar">

            <!-- ROI SPECIFIC CARDS -->
            <div id="card-sensor-settings" class="card">
                <h3>Camera Config</h3>
                <div style="margin-bottom: 10px;">
                    <label style="display:block; margin-bottom:5px;">Sensor Model:</label>
                    <div class="dropdown" style="position: relative; display: inline-block; width: 100%;">
                        <button class="btn btn-secondary" style="width: 100%; text-align: left;"
                            onclick="document.getElementById('resDropdown').style.display = document.getElementById('resDropdown').style.display === 'block' ? 'none' : 'block'"
                            id="sensor-res-label">Select Sensor</button>
                        <div id="resDropdown"
                            style="display: none; position: absolute; background-color: #f9f9f9; min-width: 100%; box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2); z-index: 10;">
                            <div style="padding: 5px 10px; font-weight: bold; background: #eee;">OV2640</div>
                            <a href="#" style="color: black; padding: 8px 16px; display: block; text-decoration:none;"
                                onclick="setSensorRes(1600, 1200, 'OV2640 (1600x1200)'); document.getElementById('resDropdown').style.display='none'; return false;">UxGA
                                (1600x1200)</a>

                            <div style="padding: 5px 10px; font-weight: bold; background: #eee;">OV3660</div>
                            <a href="#" style="color: black; padding: 8px 16px; display: block; text-decoration:none;"
                                onclick="setSensorRes(2048, 1536, 'OV3660 (2048x1536)'); document.getElementById('resDropdown').style.display='none'; return false;">QXGA
                                (2048x1536)</a>

                            <div style="padding: 5px 10px; font-weight: bold; background: #eee;">OV5640</div>
                            <a href="#" style="color: black; padding: 8px 16px; display: block; text-decoration:none;"
                                onclick="setSensorRes(2592, 1944, 'OV5640 (2592x1944)'); document.getElementById('resDropdown').style.display='none'; return false;">QSXGA
                                (2592x1944)</a>
                        </div>
                    </div>
                </div>

                <div style="display: flex; gap: 5px; align-items: center; margin-bottom: 10px;">
                    <input type="checkbox" id="force43" onchange="state.force43 = this.checked; generateOutput()">
                    <label for="force43" style="cursor: pointer; user-select: none;">Force 4:3 (Div by 8)</label>
                </div>

                <div style="margin-top: 10px;">
                    <label style="display:block; margin-bottom:5px;">Rotation:</label>
                    <div style="display: flex; gap: 5px; flex-wrap: wrap;">
                        <button class="btn btn-secondary" style="flex:1; padding: 4px;"
                            onclick="setRotation(0)">0Â°</button>
                        <button class="btn btn-secondary" style="flex:1; padding: 4px;"
                            onclick="setRotation(90)">90Â°</button>
                        <button class="btn btn-secondary" style="flex:1; padding: 4px;"
                            onclick="setRotation(180)">180Â°</button>
                        <button class="btn btn-secondary" style="flex:1; padding: 4px;"
                            onclick="setRotation(270)">270Â°</button>
                    </div>
                </div>
            </div>

            <div id="card-sensor-roi" class="card">
                <h3>Target Sensor ROI</h3>
                <p style="font-size: 0.85em; color: #666; margin-bottom: 10px;">
                    Define the hardware window (Blue) on the sensor.
                </p>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px;">
                    <div>
                        <label>Off_X:</label> <input type="number" id="manual_x" onchange="updateROIFromInput()"
                            style="width: 50px;">
                    </div>
                    <div>
                        <label>Off_Y:</label> <input type="number" id="manual_y" onchange="updateROIFromInput()"
                            style="width: 50px;">
                    </div>
                    <div>
                        <label>Width:</label> <input type="number" id="manual_w" onchange="updateROIFromInput()"
                            style="width: 50px;">
                    </div>
                    <div>
                        <label>Height:</label> <input type="number" id="manual_h" onchange="updateROIFromInput()"
                            style="width: 50px;">
                    </div>
                </div>
            </div>

            <!-- SHARED TARGET RES (Shown for Digits & Analog) -->
            <div id="card-target-res" class="card" style="display:none;">
                <h3>Target Resolution</h3>
                <p style="font-size: 0.85em; color: #666; margin-top: 5px;">
                    Set the desired output resolution (scaling) for the component(s).
                </p>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-top: 10px;">
                    <div>
                        <label>Target H:</label> <input type="number" id="target_h" placeholder="e.g 480"
                            onchange="generateOutput()" style="width: 70px;">
                    </div>
                    <div>
                        <label>Target W:</label> <input type="number" id="target_w" placeholder="e.g 640"
                            onchange="generateOutput()" style="width: 70px;">
                    </div>
                </div>
                <div style="margin-top: 5px;">
                    <button class="btn btn-secondary" style="font-size: 0.8em; padding: 4px 8px;"
                        onclick="setTargetRes(640, 480)">VGA (640x480)</button>
                    <button class="btn btn-secondary" style="font-size: 0.8em; padding: 4px 8px;"
                        onclick="setTargetRes(800, 600)">SVGA (800x600)</button>
                    <button class="btn btn-secondary" style="font-size: 0.8em; padding: 4px 8px;"
                        onclick="setTargetRes(1024, 768)">XGA (1024x768)</button>
                    <button class="btn btn-secondary" style="font-size: 0.8em; padding: 4px 8px;"
                        onclick="setTargetRes('','')">Reset (1:1)</button>
                </div>
            </div>

            <!-- ACTIONS (ROI) -->
            <div id="card-actions-roi" class="card">
                <h3>Actions</h3>
                <button class="btn btn-danger" style="width: 100%; margin-bottom: 10px;" onclick="resetCurrent()">Clear
                    ROI</button>
                <button class="btn btn-danger" style="width: 100%;" onclick="resetAll()">Reset All</button>
            </div>

            <!-- ACTIONS (DIGITS) -->
            <div id="card-actions-digits" class="card" style="display:none;">
                <h3>Actions</h3>
                <button class="btn btn-secondary" style="width: 100%; margin-bottom: 10px;"
                    onclick="resetCurrent()">Undo Last Digit</button>
                <button class="btn btn-danger" style="width: 100%;"
                    onclick="state.digits=[]; updateCanvas(); generateOutput();">Clear All Digits</button>
            </div>

            <!-- ACTIONS (ANALOG) -->
            <div id="card-actions-analog" class="card" style="display:none;">
                <h3>Actions</h3>
                <button class="btn btn-secondary" style="width: 100%; margin-bottom: 10px;"
                    onclick="resetCurrent()">Undo Last Dial</button>
                <button class="btn btn-danger" style="width: 100%;"
                    onclick="state.dials=[]; updateCanvas(); generateOutput();">Clear All Dials</button>
            </div>

        </div>

    </div>
    <script>
        // State
        let state = {
            image: null,
            rotation: 0, // 0, 90, 180, 270
            mode: 'roi', // 'roi', 'digits'
            roi: null, // {x, y, w, h} in ROTATED coordinates
            digits: [], // Array of {x, y, w, h} in ROTATED coordinates relative to 0,0 of canvas
            dials: [], // Array of {x, y, w, h} for analog dials
            isDrawing: false,
            startPos: null,
            sensorRes: { w: 1600, h: 1200, name: "OV2640 UXGA (1600x1200)" },
            force43: false
        };

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Init
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseleave', stopDrawing);
        document.getElementById('imageInput').addEventListener('change', handleImageUpload);

        function handleImageUpload(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    state.image = img;
                    // Auto-set Target Resolution (Respecting current rotation)
                    const dims = getTransformedDimensions();
                    document.getElementById('target_w').value = dims.w;
                    document.getElementById('target_h').value = dims.h;

                    state.roi = null;
                    state.digits = [];
                    updateImageInfo();
                    updateCanvas();
                    generateOutput();
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }

        function updateImageInfo() {
            const infoDiv = document.getElementById('image-info') || createImageInfoDiv();
            if (state.image) {
                infoDiv.textContent = `Image Size: ${state.image.width} x ${state.image.height}`;
            } else {
                infoDiv.textContent = '';
            }
        }

        function setSensorRes(w, h, name) {
            state.sensorRes = { w, h, name };
            document.getElementById('sensor-res-label').textContent = name;
            generateOutput();
        }

        function setTargetRes(w, h) {
            document.getElementById('target_w').value = w;
            document.getElementById('target_h').value = h;
            generateOutput();
        }

        function createImageInfoDiv() {
            const div = document.createElement('div');
            div.id = 'image-info';
            div.style.marginLeft = '10px';
            div.style.fontWeight = 'bold';
            div.style.color = '#555';
            // Insert after file input controls
            const controls = document.querySelector('.controls');
            controls.appendChild(div);
            return div;
        }

        function setRotation(deg) {
            state.rotation = deg;
            // When rotation changes, ROI and Digits are invalid visually unless we map them.
            // For simplicity in this tool, we CLEAR them to avoid confusion, 
            // as usually you set rotation first then draw.
            if (confirm("Changing rotation will clear current regions. Continue?")) {
                state.roi = null;
                state.dials = [];
                // Update Target Res to match new rotation
                const dims = getTransformedDimensions();
                document.getElementById('target_w').value = dims.w;
                document.getElementById('target_h').value = dims.h;

                updateCanvas();
                generateOutput();
            }
        }

        function setMode(mode) {
            state.mode = mode;
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('btn-mode-' + mode).classList.add('active');

            const help = document.getElementById('help-text');
            if (mode === 'roi') help.textContent = "Draw a rectangle to define the Camera Window (Blue). Optional: If skipped, full sensor is used.";
            else if (mode === 'digits') help.textContent = "Draw boxes around each digit (Green).";
            else if (mode === 'analog') help.textContent = "Click Center & Drag to create a Square Dial (Orange).";

            // VISIBILITY LOGIC
            const hide = (id) => { const el = document.getElementById(id); if (el) el.style.display = 'none'; };
            const show = (id) => { const el = document.getElementById(id); if (el) el.style.display = 'block'; };

            // Reset all first
            hide('card-sensor-settings');
            hide('card-sensor-roi');
            hide('card-target-res');
            hide('card-actions-roi');
            hide('card-actions-digits');
            hide('card-actions-analog');

            if (mode === 'roi') {
                show('card-sensor-settings');
                show('card-sensor-roi');
                show('card-actions-roi');
            } else if (mode === 'digits') {
                show('card-target-res');
                show('card-actions-digits');
            } else if (mode === 'analog') {
                show('card-target-res');
                show('card-actions-analog');
            }

            updateCanvas();
        }

        function getTransformedDimensions() {
            if (!state.image) return { w: 800, h: 600 };
            if (state.rotation === 0 || state.rotation === 180) {
                return { w: state.image.width, h: state.image.height };
            } else {
                return { w: state.image.height, h: state.image.width };
            }
        }

        function updateCanvas() {
            const dims = getTransformedDimensions();
            canvas.width = dims.w;
            canvas.height = dims.h;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (!state.image) {
                ctx.fillStyle = '#ccc';
                ctx.textAlign = 'center';
                ctx.fillText('No Image Loaded', canvas.width / 2, canvas.height / 2);
                return;
            }

            // Draw Rotated Image
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.rotate(state.rotation * Math.PI / 180);
            ctx.drawImage(state.image, -state.image.width / 2, -state.image.height / 2);
            ctx.restore();

            // Draw ROI
            if (state.roi) {
                ctx.strokeStyle = '#3498db';
                ctx.lineWidth = 3;
                ctx.fillStyle = 'rgba(52, 152, 219, 0.2)';
                ctx.fillRect(state.roi.x, state.roi.y, state.roi.w, state.roi.h);
                ctx.strokeRect(state.roi.x, state.roi.y, state.roi.w, state.roi.h);

                // Dim outside ROI
                /*
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.beginPath();
                ctx.rect(0, 0, canvas.width, canvas.height);
                ctx.rect(state.roi.x, state.roi.y, state.roi.w, state.roi.h);
                ctx.fill('evenodd');
                */

                // Sync Manual Inputs to Visual ROI
                if (!state.isManualUpdate) {
                    document.getElementById('manual_x').value = state.roi.x;
                    document.getElementById('manual_y').value = state.roi.y;
                    document.getElementById('manual_w').value = state.roi.w;
                    document.getElementById('manual_h').value = state.roi.h;
                }
            } else {
                // Clear inputs if no ROI
                if (!state.isManualUpdate) {
                    document.getElementById('manual_x').value = "";
                    document.getElementById('manual_y').value = "";
                    document.getElementById('manual_w').value = "";
                    document.getElementById('manual_h').value = "";
                }
            }

            // Draw Digits
            drawZones(state.digits, '#2ecc71', '#');

            // Draw Dials
            drawZones(state.dials, '#f39c12', 'D');
        }

        // Coordinate Mapping: Rotated (Canvas) -> Original (Sensor)
        function mapToOriginal(x, y, w, h) {
            const W = state.image.width;
            const H = state.image.height;
            let ox, oy, ow, oh;

            // Note: Standard image rotation usually is center-based
            // 0: x,y
            // 90 (CW): x'=H-y, y'=x  (Mapping FROM original TO rotated)
            // We need FROM rotated TO original

            // Rotated Dims
            const RW = (state.rotation % 180 === 0) ? W : H;
            const RH = (state.rotation % 180 === 0) ? H : W;

            switch (state.rotation) {
                case 0:
                    ox = x; oy = y; ow = w; oh = h;
                    break;
                case 90:
                    // new x is old y, new y is old (W-x)
                    // Inverse: old x = y (rotated), old y = RW - x (rotated) - h (rotated-orient) ?
                    // Let's think corners.
                    // Rotated (x,y) -> Original?
                    // 90 CW: Top Right of Orig becomes Bottom Right of Rotated? No.
                    // 90 CW: 
                    // (0,0) orig -> (H, 0) rot? NO.
                    // (0,0) orig -> (RH, 0) rot?
                    // Let's use standard transform logic.
                    // cw90: (x,y) -> (H-y, x) (assuming 0-indexed)
                    // Inverse cw90 is ccw90: (x,y) -> (y, W-x)

                    // But we have a rectangle.
                    // Rot Rect (x,y,w,h).
                    // TL(x,y) -> (y, W-x).
                    // TR(x+w,y) -> (y, W-(x+w)).
                    // BL(x,y+h) -> (y+h, W-x).
                    // We need bounding box in original space.

                    // CCW 90 of (x,y) in RWxRH space:
                    // ox = y
                    // oy = RW - x // (RW is H of original) ... wait.

                    // Let's trace simpler:
                    // Rotated 90 (CW). Width=H_orig, Height=W_orig.
                    // Point P_rot(u, v).
                    // P_orig(v, H_rot - u).  where H_rot is Width_orig.

                    // Example: Rot(10, 10). H_rot=100.
                    // Orig(10, 100-10) = (10, 90).
                    // Let's verify 90CW of (10,90). (100-90, 10) = (10,10). Correct.

                    // So: ox = y; oy = (RW) - (x + w); 
                    // ow = h; oh = w;
                    ox = y;
                    oy = RW - (x + w);
                    ow = h;
                    oh = w;
                    break;

                case 180:
                    // (x,y) -> (W-x, H-y)
                    // Inverse is same.
                    ox = RW - (x + w);
                    oy = RH - (y + h);
                    ow = w;
                    oh = h;
                    break;

                case 270: // 90 CCW
                    // (x,y) -> (y, W-x)
                    // Inverse is 90 CW: (x,y) -> (RH-y, x)
                    ox = RH - (y + h);
                    oy = x;
                    ow = h;
                    oh = w;
                    break;
            }

            // Ensure integer
            return {
                x: Math.round(ox),
                y: Math.round(oy),
                w: Math.round(ow),
                h: Math.round(oh)
            };
        }

        function snapTo8(val) {
            return Math.round(val / 8) * 8;
        }

        function calculateZoneCoordinates(vis_rect, off_x, off_y, scale_x, scale_y, w, h) {
            // 1. Visual -> Sensor Global (Original Unrotated)
            const sensor_g = mapToOriginal(vis_rect.x, vis_rect.y, vis_rect.w, vis_rect.h);
            const d_sensor_x = sensor_g.x * scale_x;
            const d_sensor_y = sensor_g.y * scale_y;
            const d_sensor_w = sensor_g.w * scale_x;
            const d_sensor_h = sensor_g.h * scale_y;

            // 2. Relativize to Snapped Window (in Sensor Space)
            let rel_x = d_sensor_x - off_x;
            let rel_y = d_sensor_y - off_y;

            // 3. Transform to Configured Rotation Space (Final Output)
            let out_w = (state.rotation % 180 === 0) ? w : h;
            let out_h = (state.rotation % 180 === 0) ? h : w;

            let fin_x, fin_y, fin_w, fin_h;

            switch (state.rotation) {
                case 0: fin_x = rel_x; fin_y = rel_y; fin_w = d_sensor_w; fin_h = d_sensor_h; break;
                case 90: fin_x = out_w - rel_y - d_sensor_h; fin_y = rel_x; fin_w = d_sensor_h; fin_h = d_sensor_w; break;
                case 180: fin_x = out_w - rel_x - d_sensor_w; fin_y = out_h - rel_y - d_sensor_h; fin_w = d_sensor_w; fin_h = d_sensor_h; break;
                case 270: fin_x = rel_y; fin_y = out_h - rel_x - d_sensor_w; fin_w = d_sensor_h; fin_h = d_sensor_w; break;
            }

            return { x: Math.round(fin_x), y: Math.round(fin_y), w: Math.round(fin_w), h: Math.round(fin_h) };
        }

        function drawZones(zones, color, labelPrefix) {
            zones.forEach((d, i) => {
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                // Light transparent fill matching stroke
                // Simple hack: assume hex color input and add opacity? 
                // Or just hardcode based on type since we only resolve duplication.
                // Let's passed fill color or derive it? The validation logic just wanted to reduce duplication.
                // The original code used different fill colors.
                // For 'digits' (#2ecc71) -> rgba(46, 204, 113, 0.3)
                // For 'dials' (#f39c12) -> rgba(243, 156, 18, 0.3)
                // We'll keep it simple and just set styles here based on color input being a key or just hardcode if easy.

                // Let's stick to original colors by checking color string since we only have 2 types
                if (color === '#2ecc71') ctx.fillStyle = 'rgba(46, 204, 113, 0.3)';
                else if (color === '#f39c12') ctx.fillStyle = 'rgba(243, 156, 18, 0.3)';
                else ctx.fillStyle = 'rgba(128, 128, 128, 0.3)';

                ctx.fillRect(d.x, d.y, d.w, d.h);
                ctx.strokeRect(d.x, d.y, d.w, d.h);

                ctx.fillStyle = '#fff';
                ctx.font = '12px sans-serif';
                ctx.globalAlpha = 1.0;
                ctx.fillText(`${labelPrefix}${i + 1}`, d.x + 2, d.y + 12);
            });
        }

        function checkOutsideROI(x, y, w, h, name) {
            // Define the bounding box (Visual Coordinates)
            let box_x = 0;
            let box_y = 0;
            let box_w = canvas.width;
            let box_h = canvas.height;

            if (state.roi) {
                box_x = state.roi.x;
                box_y = state.roi.y;
                box_w = state.roi.w;
                box_h = state.roi.h;
            }

            // Strict check with 1px margin
            const margin = 1;
            const safe_x1 = box_x + margin;
            const safe_y1 = box_y + margin;
            const safe_x2 = box_x + box_w - margin;
            const safe_y2 = box_y + box_h - margin;

            const rect_x1 = x;
            const rect_y1 = y;
            const rect_x2 = x + w;
            const rect_y2 = y + h;

            if (rect_x1 < safe_x1 || rect_y1 < safe_y1 || rect_x2 > safe_x2 || rect_y2 > safe_y2) {
                return !confirm(`Warning: ${name} is too close to the edge (margin ${margin}px required). Keep it?`);
            }
            return false;
        }

        function generateOutput() {
            const ta = document.getElementById('output');
            if (!state.image) { ta.value = ""; return; }

            let lines = [];

            // Output Scaling Logic
            const target_w_in = document.getElementById('target_w').value;
            const target_h_in = document.getElementById('target_h').value;
            let target_w = parseInt(target_w_in);
            let target_h = parseInt(target_h_in);
            let use_scaling = !isNaN(target_w) && !isNaN(target_h) && target_w > 0 && target_h > 0;

            // ... (Dimensions) ...

            // Image Dimensions (Unrotated - how it was loaded)
            const img_w = state.image.width;
            const img_h = state.image.height;

            // Sensor Dimensions
            let sensor_w = state.sensorRes.w;
            let sensor_h = state.sensorRes.h;

            // Calculate Scale Factor (Sensor / Visual)
            let scale_x = sensor_w / img_w;
            let scale_y = sensor_h / img_h;

            let anisotropic = Math.abs(scale_x - scale_y) > 0.1;

            lines.push(`# Sensor: ${state.sensorRes.name}`);
            lines.push(`# Image: ${img_w}x${img_h}`);
            lines.push(`# Scale: ${scale_x.toFixed(2)}x (Horizontal)`);
            if (anisotropic) lines.push(`# WARNING: Anisotropic scaling detected! (${scale_x.toFixed(2)} vs ${scale_y.toFixed(2)})`);
            lines.push(`rotation: ${state.rotation}`);

            // ROI Variables
            let off_x = 0;
            let off_y = 0;
            let w = sensor_w; // Default to full sensor
            let h = sensor_h;

            if (state.roi) {
                // 1. Map Visual ROI -> Unrotated Image Coordinates (0-img_w)
                const visROI = mapToOriginal(state.roi.x, state.roi.y, state.roi.w, state.roi.h);

                // 2. Scale to Sensor Coordinates
                let raw_x = visROI.x * scale_x;
                let raw_y = visROI.y * scale_y;
                let raw_w = visROI.w * scale_x;
                let raw_h = visROI.h * scale_y;

                if (state.force43) {
                    // Force 4:3 Ratio logic (also adhering to Divisible by 8)
                    let nw = raw_w / 32;
                    let nh = raw_h / 24;
                    let n = Math.max(1, Math.round(Math.max(nw, nh)));

                    let target_w = n * 32;
                    let target_h = n * 24; // 4:3 ratio (Div 8)

                    // Center it
                    let cx = raw_x + raw_w / 2;
                    let cy = raw_y + raw_h / 2;

                    let new_x = cx - target_w / 2;
                    let new_y = cy - target_h / 2;

                    off_x = snapTo8(Math.max(0, new_x));
                    off_y = snapTo8(Math.max(0, new_y));
                    w = target_w;
                    h = target_h;

                    lines.push(`# Enforcement: 4:3 Aspect Ratio (W/H = ${w}/${h}) & DivBy8`);
                } else {
                    // 3. Snap to 8 (Flexible Ratio)
                    off_x = snapTo8(Math.max(0, raw_x));
                    off_y = snapTo8(Math.max(0, raw_y));
                    w = snapTo8(Math.max(8, raw_w));
                    h = snapTo8(Math.max(8, raw_h));
                }

                // Explanatory Comments for Swapped Dims
                let comment_w = "# multiple of 8";
                let comment_h = "# multiple of 8";

                if (state.rotation === 90 || state.rotation === 270) {
                    comment_w += " (Visual Height)";
                    comment_h += " (Visual Width)";
                }

                // 4. Bounds Check (Sensor Space)
                if (off_x + w > sensor_w) lines.push(`# WARNING: ROI width exceeds sensor bounds!`);
                if (off_y + h > sensor_h) lines.push(`# WARNING: ROI height exceeds sensor bounds!`);

                lines.push(`camera_window:`);
                lines.push(`  offset_x: ${off_x} # multiple of 8`);
                lines.push(`  offset_y: ${off_y} # multiple of 8`);
                lines.push(`  width: ${w} ${comment_w}`);
                lines.push(`  height: ${h} ${comment_h}`);
            } else {
                lines.push(`# No Camera ROI defined. Assuming full sensor frame.`);
                // We keep off_x, off_y at 0
                // w, h are set to sensor_w, sensor_h
                // Note: If using full frame, ensure width/height match rotation logic if we printed them,
                // but we aren't printing camera_window, so just internal variables for digit calc.

                // IMPORTANT: 'w' and 'h' are used for Digit Relative calculation and Rotation Logic.
                // In Rotation Logic:
                // let out_w = (state.rotation % 180 === 0) ? w : h;
                // If w=1600, h=1200 (Sensor).
                // Rotation 90. out_w = 1200.
                // This seems correct.
            }

            // Scaling Factor for Crop Zones
            // The ROI determines the "Source" image size (w, h)
            // If use_scaling is true, we map (w, h) -> (target_w, target_h)
            let final_scale_x = 1.0;
            let final_scale_y = 1.0;

            if (use_scaling) {
                // Warning if aspect ratio mismatch
                let roi_ratio = w / h; // Note: w,h are already rotated-aware in logic?
                // Wait, 'w' and 'h' above are SENSOR SPACE WIDTH/HEIGHT (Unrotated relative to sensor).
                // But target_w/target_h are OUTPUT IMAGE DIMENSIONS (Rotated?)

                // Let's look at logic:
                // calculateZoneCoordinates returns coordinates in "ROI Space" (optionally rotated).
                // If we want to scale to target, we should apply scaling to the result of calculateZoneCoordinates.

                // Wait, logic check:
                // calculateZoneCoordinates returns {x, y, w, h} which are relative to the "Output Image".
                // Currently "Output Image" == "ROI size" (rotated).

                // If we simply scale the output of calculateZoneCoordinates, it should work.
                // We need the "Unscaled Output Size" to calculate the factor.

                let unscaled_out_w = (state.rotation % 180 === 0) ? w : h;
                let unscaled_out_h = (state.rotation % 180 === 0) ? h : w;

                final_scale_x = target_w / unscaled_out_w;
                final_scale_y = target_h / unscaled_out_h;

                lines.push(`# Output Scaling Active: Mapping ${unscaled_out_w}x${unscaled_out_h} (ROI) -> ${target_w}x${target_h}`);
            }


            // Digits
            if (state.digits.length > 0) {
                const zones = state.digits.map(d_vis => {
                    const res = calculateZoneCoordinates(d_vis, off_x, off_y, scale_x, scale_y, w, h);

                    // Apply Scaling
                    if (use_scaling) {
                        res.x = Math.round(res.x * final_scale_x);
                        res.y = Math.round(res.y * final_scale_y);
                        res.w = Math.round(res.w * final_scale_x);
                        res.h = Math.round(res.h * final_scale_y);
                    }

                    return [res.x, res.y, res.x + res.w, res.y + res.h];
                });

                // Single-line JSON string format
                const jsonStr = JSON.stringify(zones);
                lines.push(``);

                if (!state.roi) {
                    lines.push(`# Crop Zones (Sensor Space - Full Frame)`);
                } else {
                    lines.push(`# Crop Zones (Sensor Space - Relative to Window)`);
                }
                lines.push(`initial_value: '"${jsonStr}"'`);
            }

            // Analog Dials
            if (state.dials.length > 0) {
                // Same logic as digits
                const dials_yaml = state.dials.map((d_vis, i) => {
                    const res = calculateZoneCoordinates(d_vis, off_x, off_y, scale_x, scale_y, w, h);

                    // Apply Scaling
                    if (use_scaling) {
                        res.x = Math.round(res.x * final_scale_x);
                        res.y = Math.round(res.y * final_scale_y);
                        res.w = Math.round(res.w * final_scale_x);
                        res.h = Math.round(res.h * final_scale_y);
                    }

                    const scaleVal = Math.pow(10, -(i + 1));

                    return `    - id: dial_${i + 1}
      # scale: ${scaleVal}
      crop_x: ${res.x}
      crop_y: ${res.y}
      crop_w: ${res.w}
      crop_h: ${res.h}
      min_angle: 0
      max_angle: 360
      min_value: 0
      max_value: 10`;
                });

                lines.push(``);
                lines.push(`# Analog Dials Config`);
                lines.push(`analog_reader:`);
                lines.push(`  dials:`);
                lines.push(dials_yaml.join('\n'));
            }

            ta.value = lines.join('\n');
        }

        // Interaction
        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (e.clientX - rect.left),
                y: (e.clientY - rect.top)
            };
        }

        function startDrawing(e) {
            if (!state.image) return;
            state.isDrawing = true;
            state.startPos = getMousePos(e);
        }

        function draw(e) {
            if (!state.isDrawing) return;
            const pos = getMousePos(e);
            const w = pos.x - state.startPos.x;
            const h = pos.y - state.startPos.y;

            updateCanvas(); // Clear old partial rect

            // Draw scratch rect
            let color = '#3498db'; // ROI
            if (state.mode === 'digits') color = '#2ecc71';
            if (state.mode === 'analog') color = '#f39c12';

            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);

            if (state.mode === 'analog') {
                // ctx.strokeStyle = '#f39c12'; // Consolidate color logic removed
                // Center-based Square
                let dist = Math.max(Math.abs(pos.x - state.startPos.x), Math.abs(pos.y - state.startPos.y));
                let cx = state.startPos.x;
                let cy = state.startPos.y;
                ctx.strokeRect(cx - dist, cy - dist, dist * 2, dist * 2);
            } else {
                ctx.strokeRect(state.startPos.x, state.startPos.y, w, h);
            }

            ctx.setLineDash([]);
        }

        function stopDrawing(e) {
            if (!state.isDrawing) return;
            state.isDrawing = false;
            const pos = getMousePos(e);

            // Normalize Rect
            let x, y, w, h;

            if (state.mode === 'analog') {
                // Center-based Square
                let dist = Math.max(Math.abs(pos.x - state.startPos.x), Math.abs(pos.y - state.startPos.y));
                let cx = state.startPos.x;
                let cy = state.startPos.y;
                x = cx - dist;
                y = cy - dist;
                w = dist * 2;
                h = dist * 2;
            } else {
                x = Math.min(state.startPos.x, pos.x);
                y = Math.min(state.startPos.y, pos.y);
                w = Math.abs(pos.x - state.startPos.x);
                h = Math.abs(pos.y - state.startPos.y);
            }

            // Snap/Min size
            if (w < 4 || h < 4) return;

            if (state.mode === 'roi') {
                state.roi = { x, y, w, h };
                state.digits = []; // Reset digits if ROI changes
                state.dials = [];
            } else if (state.mode === 'digits') {
                if (checkOutsideROI(x, y, w, h, 'Zone')) return;
                state.digits.push({ x: x, y: y, w: w, h: h });
            } else if (state.mode === 'analog') {
                if (checkOutsideROI(x, y, w, h, 'Dial')) return;
                state.dials.push({ x: x, y: y, w: w, h: h });
            }

            updateCanvas();
            generateOutput();
        }

        function resetCurrent() {
            if (state.mode === 'roi') state.roi = null;
            if (state.mode === 'digits') state.digits.pop(); // Undo last
            if (state.mode === 'analog') state.dials.pop(); // Undo last
            updateCanvas();
            generateOutput();
        }

        function resetAll() {
            state.roi = null;
            state.digits = [];
            state.dials = [];
            updateCanvas();
            generateOutput();
        }

        function copyOutput() {
            const copyText = document.getElementById("output");
            navigator.clipboard.writeText(copyText.value).then(() => {
                alert("Copied to clipboard");
            }).catch(err => {
                alert("Failed to copy. See console for details.");
                console.error('Failed to copy text: ', err);
            });
        }
        // Coordinate Mapping: Original (Sensor) -> Rotated (Canvas) - INVERSE
        function mapFromOriginal(ox, oy, ow, oh) {
            const W = state.image.width;
            const H = state.image.height;
            let x, y, w, h;

            // Rotated Dims (Canvas Dims)
            const RW = (state.rotation % 180 === 0) ? W : H;
            const RH = (state.rotation % 180 === 0) ? H : W;

            switch (state.rotation) {
                case 0:
                    x = ox; y = oy; w = ow; h = oh;
                    break;
                case 90:
                    // Inverse 90 CW
                    // x = RW - oy - oh
                    // y = ox
                    // w = oh
                    // h = ow
                    x = RW - oy - oh;
                    y = ox;
                    w = oh;
                    h = ow;
                    break;
                case 180:
                    // Inverse 180
                    // x = RW - ox - ow
                    // y = RH - oy - oh
                    x = RW - ox - ow;
                    y = RH - oy - oh;
                    w = ow;
                    h = oh;
                    break;
                case 270: // 90 CCW
                    // Inverse 270 (which is 90 CW from Rotated perspective)
                    // x = oy
                    // y = RH - ox - w (wait, h?)
                    // From mapToOrignial 270: ox = RH - (y+h). -> ox = RH - y - h -> y = RH - ox - h. Correct.
                    x = oy;
                    y = RH - ox - ow; // FIXED: Visual Y depends on Visual Height (Sensor Width)
                    w = oh;
                    h = ow;
                    break;
            }

            return { x, y, w, h };
        }

        function updateROIFromInput() {
            if (!state.image) return;
            // Inputs are SENSOR coordinates
            const off_x = parseInt(document.getElementById('manual_x').value) || 0;
            const off_y = parseInt(document.getElementById('manual_y').value) || 0;
            const w_in = parseInt(document.getElementById('manual_w').value) || 100;
            const h_in = parseInt(document.getElementById('manual_h').value) || 100;

            // 1. Unscale: Sensor -> Unrotated Image Space
            const img_w = state.image.width;
            const img_h = state.image.height;
            const sensor_w = state.sensorRes.w;
            const sensor_h = state.sensorRes.h;

            const scale_x = sensor_w / img_w;
            const scale_y = sensor_h / img_h;

            let ox = off_x / scale_x;
            let oy = off_y / scale_y;
            let ow = w_in / scale_x;
            let oh = h_in / scale_y;

            // 2. Unmap: Unrotated Image Space -> Rotated Visual Space
            const vis = mapFromOriginal(ox, oy, ow, oh);

            // 3. Set State (Visual)
            state.roi = {
                x: Math.round(vis.x),
                y: Math.round(vis.y),
                w: Math.round(vis.w),
                h: Math.round(vis.h)
            };

            state.isManualUpdate = true; // prevent loop
            updateCanvas();
            generateOutput(); // This will snap values and update inputs again, but that's okay (auto-correction)
            state.isManualUpdate = false;
        }


        setMode("roi");
    </script>
</body>

</html>