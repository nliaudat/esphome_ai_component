<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32 AI Rotation & ROI Tool v3</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 20px;
            background-color: #f0f2f5;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            gap: 20px;
        }

        .main-panel {
            flex: 2;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .sidebar {
            flex: 1;
            min-width: 350px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        h1,
        h2,
        h3 {
            margin-top: 0;
            color: #2c3e50;
        }

        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 20px;
            align-items: center;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
        }

        .btn-primary {
            background-color: #3498db;
            color: white;
        }

        .btn-primary:hover {
            background-color: #2980b9;
        }

        .btn-danger {
            background-color: #e74c3c;
            color: white;
        }

        .btn-secondary {
            background-color: #95a5a6;
            color: white;
        }

        .btn.active {
            box-shadow: 0 0 0 2px #2c3e50;
            transform: translateY(1px);
        }

        .canvas-wrapper {
            position: relative;
            overflow: auto;
            max-height: 80vh;
            border: 1px solid #ddd;
            background-image: repeating-linear-gradient(45deg, #eee 25%, transparent 25%, transparent 75%, #eee 75%, #eee), repeating-linear-gradient(45deg, #eee 25%, #fff 25%, #fff 75%, #eee 75%, #eee);
            background-position: 0 0, 10px 10px;
            background-size: 20px 20px;
        }

        canvas {
            display: block;
            cursor: crosshair;
        }

        textarea {
            width: 100%;
            height: 300px;
            font-family: monospace;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            resize: vertical;
        }

        .status-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.9em;
            margin-left: 10px;
        }

        .status-mode {
            background: #e8f6f3;
            color: #1abc9c;
            border: 1px solid #1abc9c;
        }

        .help-text {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 10px;
        }

        .mode-toggles {
            display: flex;
            margin-bottom: 15px;
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid #bdc3c7;
        }

        .mode-btn {
            flex: 1;
            padding: 10px;
            border: none;
            background: #f8f9fa;
            cursor: pointer;
            font-weight: 500;
        }

        .mode-btn.active {
            background: #3498db;
            color: white;
        }

        .mode-btn:not(:last-child) {
            border-right: 1px solid #bdc3c7;
        }

        .legend {
            margin-top: 10px;
            font-size: 0.85em;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-bottom: 5px;
        }

        .color-box {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        /* Help Sidebar CSS */
        .help-sidebar {
            flex: 1;
            min-width: 300px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .step-list {
            margin: 0;
            padding-left: 20px;
        }

        .step-list li {
            margin-bottom: 10px;
            color: #555;
        }

        .step-highlight {
            background-color: #e8f6f3;
            border-left: 4px solid #1abc9c;
            padding: 10px;
            margin-bottom: 15px;
            border-radius: 4px;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="main-panel">
            <h1>ESP32 AI Configuration Tool</h1>

            <div class="controls">
                <input type="file" id="imageInput" accept="image/*" style="display: none;">
                <button class="btn btn-primary" onclick="document.getElementById('imageInput').click()">ðŸ“‚ Load
                    Image</button>
            </div>

            <div class="mode-toggles">
                <button class="mode-btn active" onclick="setMode('roi')" id="btn-mode-roi">1. Set Camera ROI
                    (Optional)</button>
                <button class="mode-btn" onclick="setMode('digits')" id="btn-mode-digits">2. Set Digit Zones</button>
                <button class="mode-btn" onclick="setMode('analog')" id="btn-mode-analog">3. Set Analog Dials</button>
            </div>

            <p class="help-text" id="status-text">Active Mode: Camera ROI</p>

            <div class="canvas-wrapper">
                <canvas id="canvas"></canvas>
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="color-box" style="background: rgba(52, 152, 219, 0.3); border: 2px solid #3498db;">
                    </div> Camera ROI (Blue)
                </div>
                <div class="legend-item">
                    <div class="color-box" style="background: rgba(46, 204, 113, 0.3); border: 2px solid #2ecc71;">
                    </div> Digit Zones (Green)
                </div>
                <div class="legend-item">
                    <div class="color-box" style="background: rgba(243, 156, 18, 0.3); border: 2px solid #f39c12;">
                    </div> Analog Dials (Orange)
                </div>
            </div>

            <div class="card" style="margin-top: 20px;">
                <h3>Configuration Output</h3>
                <textarea id="output" readonly style="height: 200px;"></textarea>
                <button class="btn btn-primary" style="width: 100%; margin-top: 10px;" onclick="copyOutput()">ðŸ“‹ Copy to
                    Clipboard</button>
            </div>
        </div>

        <div class="sidebar">
            <!-- ROI SPECIFIC CARDS -->
            <div id="card-sensor-settings" class="card">
                <h3>Camera Config</h3>
                <div style="margin-bottom: 10px;">
                    <label style="display:block; margin-bottom:5px;">Sensor Model:</label>
                    <div class="dropdown" style="position: relative; display: inline-block; width: 100%;">
                        <button class="btn btn-secondary" style="width: 100%; text-align: left;"
                            onclick="document.getElementById('resDropdown').style.display = document.getElementById('resDropdown').style.display === 'block' ? 'none' : 'block'"
                            id="sensor-res-label">Select Sensor</button>
                        <div id="resDropdown"
                            style="display: none; position: absolute; background-color: #f9f9f9; min-width: 100%; box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2); z-index: 10;">
                            <div style="padding: 5px 10px; font-weight: bold; background: #eee;">OV2640</div>
                            <a href="#" style="color: black; padding: 8px 16px; display: block; text-decoration:none;"
                                onclick="setSensorRes(1600, 1200, 'OV2640 (1600x1200)'); document.getElementById('resDropdown').style.display='none'; return false;">UxGA
                                (1600x1200)</a>
                            <div style="padding: 5px 10px; font-weight: bold; background: #eee;">OV3660</div>
                            <a href="#" style="color: black; padding: 8px 16px; display: block; text-decoration:none;"
                                onclick="setSensorRes(2048, 1536, 'OV3660 (2048x1536)'); document.getElementById('resDropdown').style.display='none'; return false;">QXGA
                                (2048x1536)</a>
                            <div style="padding: 5px 10px; font-weight: bold; background: #eee;">OV5640</div>
                            <a href="#" style="color: black; padding: 8px 16px; display: block; text-decoration:none;"
                                onclick="setSensorRes(2592, 1944, 'OV5640 (2592x1944)'); document.getElementById('resDropdown').style.display='none'; return false;">QSXGA
                                (2592x1944)</a>
                        </div>
                    </div>
                </div>

                <div style="display: flex; gap: 5px; align-items: center; margin-bottom: 10px;">
                    <input type="checkbox" id="force43" onchange="state.force43 = this.checked; generateOutput()">
                    <label for="force43" style="cursor: pointer; user-select: none;">Force 4:3 (Div by 8)</label>
                </div>

                <div style="margin-top: 10px;">
                    <label style="display:block; margin-bottom:5px;">Rotation:</label>
                    <div style="display: flex; gap: 5px; flex-wrap: wrap;">
                        <button class="btn btn-secondary" style="flex:1; padding: 4px;"
                            onclick="setRotation(0)">0Â°</button>
                        <button class="btn btn-secondary" style="flex:1; padding: 4px;"
                            onclick="setRotation(90)">90Â°</button>
                        <button class="btn btn-secondary" style="flex:1; padding: 4px;"
                            onclick="setRotation(180)">180Â°</button>
                        <button class="btn btn-secondary" style="flex:1; padding: 4px;"
                            onclick="setRotation(270)">270Â°</button>
                    </div>
                </div>
                <div style="margin-top: 5px; display: flex; align-items: center; gap: 5px;">
                    <label style="font-size: 0.9em;">Custom Angle:</label>
                    <input type="number" id="custom_rot" placeholder="deg"
                        onchange="setRotation(parseFloat(this.value))" style="width: 70px; padding: 4px;">
                </div>
                <div id="rot-warning"
                    style="display:none; color: #e67e22; font-size: 0.85em; margin-top: 5px; background: #fdf2e9; padding: 5px; border-left: 3px solid #e67e22; border-radius: 2px;">
                    <strong>Warning:</strong> Custom rotation is CPU intensive!
                </div>
            </div>

            <div id="card-sensor-roi" class="card">
                <h3>Target Sensor ROI</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px;">
                    <div><label>Off_X:</label> <input type="number" id="manual_x" onchange="updateROIFromInput()"
                            style="width: 50px;"></div>
                    <div><label>Off_Y:</label> <input type="number" id="manual_y" onchange="updateROIFromInput()"
                            style="width: 50px;"></div>
                    <div><label>Width:</label> <input type="number" id="manual_w" onchange="updateROIFromInput()"
                            style="width: 50px;"></div>
                    <div><label>Height:</label> <input type="number" id="manual_h" onchange="updateROIFromInput()"
                            style="width: 50px;"></div>
                </div>
            </div>

            <div id="card-target-res" class="card" style="display:none;">
                <h3>Target Resolution</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-top: 10px;">
                    <div><label>Target H:</label> <input type="number" id="target_h" placeholder="e.g 480"
                            onchange="generateOutput()" style="width: 70px;"></div>
                    <div><label>Target W:</label> <input type="number" id="target_w" placeholder="e.g 640"
                            onchange="generateOutput()" style="width: 70px;"></div>
                </div>
                <div style="margin-top: 5px;">
                    <button class="btn btn-secondary" style="font-size: 0.8em; padding: 4px 8px;"
                        onclick="setTargetRes(640, 480)">VGA (640x480)</button>
                    <button class="btn btn-secondary" style="font-size: 0.8em; padding: 4px 8px;"
                        onclick="setTargetRes(800, 600)">SVGA (800x600)</button>
                </div>
            </div>

            <!-- ACTIONS -->
            <div id="card-actions-roi" class="card">
                <h3>Actions</h3>
                <button class="btn btn-danger" style="width: 100%; margin-bottom: 10px;" onclick="resetCurrent()">Clear
                    ROI</button>
                <button class="btn btn-danger" style="width: 100%;" onclick="resetAll()">Reset All</button>
            </div>
            <div id="card-actions-digits" class="card" style="display:none;">
                <h3>Actions</h3>
                <button class="btn btn-secondary" style="width: 100%; margin-bottom: 10px;"
                    onclick="resetCurrent()">Undo Last Digit</button>
                <button class="btn btn-danger" style="width: 100%;"
                    onclick="state.digits=[]; updateCanvas(); generateOutput();">Clear All Digits</button>
            </div>
            <div id="card-actions-analog" class="card" style="display:none;">
                <h3>Actions</h3>
                <button class="btn btn-secondary" style="width: 100%; margin-bottom: 10px;"
                    onclick="resetCurrent()">Undo Last Dial</button>
                <button class="btn btn-danger" style="width: 100%;"
                    onclick="state.dials=[]; updateCanvas(); generateOutput();">Clear All Dials</button>
            </div>
        </div>

        <!-- NEW HELP SIDEBAR -->
        <div class="help-sidebar" id="help-sidebar">
            <h3>Instructions</h3>
            <div id="help-content">
                <!-- Dynamic Content -->
            </div>
        </div>

    </div>
    <script>
        // State
        let state = {
            image: null,
            rotation: 0, // 0, 90, 180, 270
            mode: 'roi', // 'roi', 'digits'
            roi: null, // {x, y, w, h} in ROTATED coordinates
            digits: [], // Array of {x, y, w, h} in ROTATED coordinates relative to 0,0 of canvas
            dials: [], // Array of {x, y, w, h} for analog dials
            isDrawing: false,
            startPos: null,
            sensorRes: { w: 1600, h: 1200, name: "OV2640 UXGA (1600x1200)" },
            force43: false
        };

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Init
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseleave', stopDrawing);
        document.getElementById('imageInput').addEventListener('change', handleImageUpload);

        function handleImageUpload(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    state.image = img;
                    // Auto-set Target Resolution (Respecting current rotation)
                    const dims = getTransformedDimensions();
                    document.getElementById('target_w').value = dims.w;
                    document.getElementById('target_h').value = dims.h;

                    state.roi = null;
                    state.digits = [];
                    updateImageInfo();
                    updateCanvas();
                    generateOutput();
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }

        function updateImageInfo() {
            const infoDiv = document.getElementById('image-info') || createImageInfoDiv();
            if (state.image) {
                infoDiv.textContent = `Image Size: ${state.image.width} x ${state.image.height}`;
            } else {
                infoDiv.textContent = '';
            }
        }

        function setSensorRes(w, h, name) {
            state.sensorRes = { w, h, name };
            document.getElementById('sensor-res-label').textContent = name;
            generateOutput();
        }

        function setTargetRes(w, h) {
            document.getElementById('target_w').value = w;
            document.getElementById('target_h').value = h;
            generateOutput();
        }

        function createImageInfoDiv() {
            const div = document.createElement('div');
            div.id = 'image-info';
            div.style.marginLeft = '10px';
            div.style.fontWeight = 'bold';
            div.style.color = '#555';
            // Insert after file input controls
            const controls = document.querySelector('.controls');
            controls.appendChild(div);
            return div;
        }

        function setRotation(deg) {
            if (isNaN(deg)) return;
            state.rotation = deg;

            // UI Sync
            const isCustom = [0, 90, 180, 270].indexOf(deg) === -1;
            const input = document.getElementById('custom_rot');
            if (input) input.value = deg;
            const warning = document.getElementById('rot-warning');
            if (warning) warning.style.display = isCustom ? 'block' : 'none';

            // When rotation changes, ROI and Digits are invalid visually unless we map them.
            // For simplicity in this tool, we CLEAR them to avoid confusion, 
            // as usually you set rotation first then draw.
            if (confirm("Changing rotation will clear current regions. Continue?")) {
                state.roi = null;
                state.dials = [];
                // Update Target Res to match new rotation
                const dims = getTransformedDimensions();
                document.getElementById('target_w').value = dims.w;
                document.getElementById('target_h').value = dims.h;

                updateCanvas();
                generateOutput();
            }
        }

        function updateHelp(mode) {
            const container = document.getElementById('help-content');
            let content = '';

            if (mode === 'roi') {
                content = `
                    <div class="step-highlight">
                        <strong>Goal:</strong> Define the active area of the camera sensor.
                    </div>
                    <ol class="step-list">
                        <li><strong>Load Image</strong>: Click 'Load Image' to simulate your camera view.</li>
                        <li><strong>Set Rotation</strong>: If your camera is mounted at an angle (e.g. 270Â°), Use the rotation buttons in 'Camera Config'.</li>
                        <li><strong>Draw ROI</strong>: Click and drag on the image to draw a BLUE rectangle. This is the only area that will be sent to the AI.</li>
                        <li><strong>Why?</strong>: A smaller ROI (Window) acts like a digital zoom and improves frame rate/perfomance.</li>
                        <li><strong>Tip</strong>: Use 'Force 4:3' if you want standard aspect ratio.</li>
                    </ol>
                `;
            } else if (mode === 'digits') {
                content = `
                    <div class="step-highlight">
                        <strong>Goal:</strong> Mark where numbers appear.
                    </div>
                    <ol class="step-list">
                        <li><strong>Draw Zones</strong>: Draw a GREEN box around each digit you want to read.</li>
                        <li><strong>Order</strong>: Draw them in reading order (Left to Right).</li>
                        <li><strong>Output</strong>: This generates coordinates relative to your ROI.</li>
                        <li><strong>Target Res</strong>: Ensure 'Target W' and 'Target H' match your AI model input size (usually auto-detected).</li>
                    </ol>
                `;
            } else if (mode === 'analog') {
                content = `
                    <div class="step-highlight">
                        <strong>Goal:</strong> Mark analog clock-dials.
                    </div>
                    <ol class="step-list">
                        <li><strong>Draw Dials</strong>: Click the CENTER of the dial and drag OUTWARDS.</li>
                        <li><strong>Shape</strong>: This creates a perfect SQUARE box (Orange).</li>
                        <li><strong>Order</strong>: Draw dials in order.</li>
                        <li><strong>Note</strong>: The AI uses 30-90% of the crop radius for needle detection.</li>
                    </ol>
                `;
            }

            container.innerHTML = content;
        }

        function setMode(mode) {
            state.mode = mode;
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('btn-mode-' + mode).classList.add('active');

            // Update Status Text
            const status = document.getElementById('status-text');
            if (mode === 'roi') status.textContent = "Active Mode: Camera ROI (Blue)";
            else if (mode === 'digits') status.textContent = "Active Mode: Digit Zones (Green)";
            else if (mode === 'analog') status.textContent = "Active Mode: Analog Dials (Orange)";

            // Update Help Sidebar
            updateHelp(mode);

            // ... (Rest of visibility logic) ...
            // VISIBILITY LOGIC
            const hide = (id) => { const el = document.getElementById(id); if (el) el.style.display = 'none'; };
            const show = (id) => { const el = document.getElementById(id); if (el) el.style.display = 'block'; };

            // Reset all first
            hide('card-sensor-settings');
            hide('card-sensor-roi');
            hide('card-target-res');
            hide('card-actions-roi');
            hide('card-actions-digits');
            hide('card-actions-analog');

            if (mode === 'roi') {
                show('card-sensor-settings');
                show('card-sensor-roi');
                show('card-actions-roi');
            } else if (mode === 'digits') {
                show('card-target-res');
                show('card-actions-digits');
            } else if (mode === 'analog') {
                show('card-target-res');
                show('card-actions-analog');
            }

            updateCanvas();
        }

        // ... (Rest of existing JS functions) ...


        function getTransformedDimensions() {
            if (!state.image) return { w: 800, h: 600 };

            const rad = state.rotation * Math.PI / 180;
            const absCos = Math.abs(Math.cos(rad));
            const absSin = Math.abs(Math.sin(rad));

            const w = state.image.width * absCos + state.image.height * absSin;
            const h = state.image.width * absSin + state.image.height * absCos;

            return { w: Math.round(w), h: Math.round(h) };
        }

        function updateCanvas() {
            const dims = getTransformedDimensions();
            canvas.width = dims.w;
            canvas.height = dims.h;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (!state.image) {
                ctx.fillStyle = '#ccc';
                ctx.textAlign = 'center';
                ctx.fillText('No Image Loaded', canvas.width / 2, canvas.height / 2);
                return;
            }

            // Draw Rotated Image
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.rotate(state.rotation * Math.PI / 180);
            ctx.drawImage(state.image, -state.image.width / 2, -state.image.height / 2);
            ctx.restore();

            // Draw ROI
            if (state.roi) {
                ctx.strokeStyle = '#3498db';
                ctx.lineWidth = 3;
                ctx.fillStyle = 'rgba(52, 152, 219, 0.2)';
                ctx.fillRect(state.roi.x, state.roi.y, state.roi.w, state.roi.h);
                ctx.strokeRect(state.roi.x, state.roi.y, state.roi.w, state.roi.h);

                // Dim outside ROI
                /*
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.beginPath();
                ctx.rect(0, 0, canvas.width, canvas.height);
                ctx.rect(state.roi.x, state.roi.y, state.roi.w, state.roi.h);
                ctx.fill('evenodd');
                */

                // Sync Manual Inputs to Visual ROI
                if (!state.isManualUpdate) {
                    document.getElementById('manual_x').value = state.roi.x;
                    document.getElementById('manual_y').value = state.roi.y;
                    document.getElementById('manual_w').value = state.roi.w;
                    document.getElementById('manual_h').value = state.roi.h;
                }
            } else {
                // Clear inputs if no ROI
                if (!state.isManualUpdate) {
                    document.getElementById('manual_x').value = "";
                    document.getElementById('manual_y').value = "";
                    document.getElementById('manual_w').value = "";
                    document.getElementById('manual_h').value = "";
                }
            }

            // Draw Digits
            drawZones(state.digits, '#2ecc71', '#');

            // Draw Dials
            drawZones(state.dials, '#f39c12', 'D');
        }

        // Coordinate Mapping: Rotated (Canvas) -> Original (Sensor)
        // Returns the Bounding Box in Sensor Space that contains the Visual Box
        function mapToOriginal(x, y, w, h) {
            const W = state.image.width; // Sensor W
            const H = state.image.height; // Sensor H

            // Canvas Center (Visual)
            const dims = getTransformedDimensions();
            const cx = dims.w / 2;
            const cy = dims.h / 2;

            // Source Center (Sensor)
            const ocx = W / 2;
            const ocy = H / 2;

            const rad = -state.rotation * Math.PI / 180; // Inverse rotation
            const cos = Math.cos(rad);
            const sin = Math.sin(rad);

            // Visual Keypoints (TL, TR, BL, BR) relative to center
            const points = [
                { x: x, y: y },
                { x: x + w, y: y },
                { x: x, y: y + h },
                { x: x + w, y: y + h }
            ];

            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

            points.forEach(p => {
                // translate to center
                const dx = p.x - cx;
                const dy = p.y - cy;

                // rotate
                const ox_rel = dx * cos - dy * sin;
                const oy_rel = dx * sin + dy * cos;

                // translate back to source center
                const ox = ox_rel + ocx;
                const oy = oy_rel + ocy;

                if (ox < minX) minX = ox;
                if (ox > maxX) maxX = ox;
                if (oy < minY) minY = oy;
                if (oy > maxY) maxY = oy;
            });

            // Clamp to sensor bounds
            minX = Math.max(0, minX);
            minY = Math.max(0, minY);
            maxX = Math.min(W, maxX);
            maxY = Math.min(H, maxY);

            return {
                x: Math.round(minX),
                y: Math.round(minY),
                w: Math.round(maxX - minX),
                h: Math.round(maxY - minY)
            };
        }

        function snapTo8(val) {
            return Math.round(val / 8) * 8;
        }

        function calculateZoneCoordinates(vis_rect, off_x, off_y, scale_x, scale_y, w, h) {
            // 1. Visual -> Sensor Global (Original Unrotated)
            const sensor_g = mapToOriginal(vis_rect.x, vis_rect.y, vis_rect.w, vis_rect.h);
            const d_sensor_x = sensor_g.x * scale_x;
            const d_sensor_y = sensor_g.y * scale_y;
            const d_sensor_w = sensor_g.w * scale_x;
            const d_sensor_h = sensor_g.h * scale_y;

            // 2. Relativize to Snapped Window (in Sensor Space)
            let rel_x = d_sensor_x - off_x;
            let rel_y = d_sensor_y - off_y;

            // 3. Return Coordinates in Sensor-Relative Space (Unrotated)
            // ImageProcessor expects crops relative to the raw input buffer (unrotated).
            // Rotation is applied AFTER cropping.

            return { x: Math.round(rel_x), y: Math.round(rel_y), w: Math.round(d_sensor_w), h: Math.round(d_sensor_h) };
        }

        function drawZones(zones, color, labelPrefix) {
            zones.forEach((d, i) => {
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                // Light transparent fill matching stroke
                // Simple hack: assume hex color input and add opacity? 
                // Or just hardcode based on type since we only resolve duplication.
                // The original code used different fill colors.
                // For 'digits' (#2ecc71) -> rgba(46, 204, 113, 0.3)
                // For 'dials' (#f39c12) -> rgba(243, 156, 18, 0.3)
                // We'll keep it simple and just set styles here based on color input being a key or just hardcode if easy.

                // Let's stick to original colors by checking color string since we only have 2 types
                if (color === '#2ecc71') ctx.fillStyle = 'rgba(46, 204, 113, 0.3)';
                else if (color === '#f39c12') ctx.fillStyle = 'rgba(243, 156, 18, 0.3)';
                else ctx.fillStyle = 'rgba(128, 128, 128, 0.3)';

                ctx.fillRect(d.x, d.y, d.w, d.h);
                ctx.strokeRect(d.x, d.y, d.w, d.h);

                ctx.fillStyle = '#fff';
                ctx.font = '12px sans-serif';
                ctx.globalAlpha = 1.0;
                ctx.fillText(`${labelPrefix}${i + 1}`, d.x + 2, d.y + 12);
            });
        }

        function checkOutsideROI(x, y, w, h, name) {
            // Define the bounding box (Visual Coordinates)
            let box_x = 0;
            let box_y = 0;
            let box_w = canvas.width;
            let box_h = canvas.height;

            if (state.roi) {
                box_x = state.roi.x;
                box_y = state.roi.y;
                box_w = state.roi.w;
                box_h = state.roi.h;
            }

            // Strict check with 1px margin
            const margin = 1;
            const safe_x1 = box_x + margin;
            const safe_y1 = box_y + margin;
            const safe_x2 = box_x + box_w - margin;
            const safe_y2 = box_y + box_h - margin;

            const rect_x1 = x;
            const rect_y1 = y;
            const rect_x2 = x + w;
            const rect_y2 = y + h;

            if (rect_x1 < safe_x1 || rect_y1 < safe_y1 || rect_x2 > safe_x2 || rect_y2 > safe_y2) {
                return !confirm(`Warning: ${name} is too close to the edge (margin ${margin}px required). Keep it?`);
            }
            return false;
        }

        function generateOutput() {
            const ta = document.getElementById('output');
            if (!state.image) { ta.value = ""; return; }

            let lines = [];

            // Output Scaling Logic
            const target_w_in = document.getElementById('target_w').value;
            const target_h_in = document.getElementById('target_h').value;
            let target_w = parseInt(target_w_in);
            let target_h = parseInt(target_h_in);
            let use_scaling = !isNaN(target_w) && !isNaN(target_h) && target_w > 0 && target_h > 0;

            // ... (Dimensions) ...

            // Image Dimensions (Unrotated - how it was loaded)
            const img_w = state.image.width;
            const img_h = state.image.height;

            // Sensor Dimensions
            let sensor_w = state.sensorRes.w;
            let sensor_h = state.sensorRes.h;

            // Calculate Scale Factor (Sensor / Visual)
            let scale_x = sensor_w / img_w;
            let scale_y = sensor_h / img_h;

            let anisotropic = Math.abs(scale_x - scale_y) > 0.1;

            // ROI Variables
            let off_x = 0;
            let off_y = 0;
            let w = sensor_w; // Default to full sensor
            let h = sensor_h;

            if (state.roi) {
                // 1. Map Visual ROI -> Unrotated Image Coordinates (0-img_w)
                const visROI = mapToOriginal(state.roi.x, state.roi.y, state.roi.w, state.roi.h);

                // 2. Scale to Sensor Coordinates
                let raw_x = visROI.x * scale_x;
                let raw_y = visROI.y * scale_y;
                let raw_w = visROI.w * scale_x;
                let raw_h = visROI.h * scale_y;

                if (state.force43) {
                    // Force 4:3 Ratio logic (also adhering to Divisible by 8)
                    let nw = raw_w / 32;
                    let nh = raw_h / 24;
                    let n = Math.max(1, Math.round(Math.max(nw, nh)));

                    let target_w = n * 32;
                    let target_h = n * 24; // 4:3 ratio (Div 8)

                    // Center it
                    let cx = raw_x + raw_w / 2;
                    let cy = raw_y + raw_h / 2;

                    let new_x = cx - target_w / 2;
                    let new_y = cy - target_h / 2;

                    off_x = snapTo8(Math.max(0, new_x));
                    off_y = snapTo8(Math.max(0, new_y));
                    w = target_w;
                    h = target_h;
                } else {
                    // 3. Snap to 8 (Flexible Ratio)
                    off_x = snapTo8(Math.max(0, raw_x));
                    off_y = snapTo8(Math.max(0, raw_y));
                    w = snapTo8(Math.max(8, raw_w));
                    h = snapTo8(Math.max(8, raw_h));
                }

                // 4. Bounds Check (Sensor Space)
                // Just for internal logic, logic below will print if needed.
            }

            // Scaling Factor for Crop Zones
            // The ROI determines the "Source" image size (w, h)
            // If use_scaling is true, we map (w, h) -> (target_w, target_h)
            let final_scale_x = 1.0;
            let final_scale_y = 1.0;

            if (use_scaling) {
                let unscaled_out_w = (state.rotation % 180 === 0) ? w : h;
                let unscaled_out_h = (state.rotation % 180 === 0) ? h : w;

                final_scale_x = target_w / unscaled_out_w;
                final_scale_y = target_h / unscaled_out_h;
            }

            // NEW YAML Structure Generation
            lines.push(`globals:`);
            lines.push(`  - id: \${id_prefix}_crop_zones`);
            lines.push(`    type: std::string`);
            // lines.push(`    # restore_value: true`);
            lines.push(`    max_restore_data_length: 254`);

            // Calculate Crop Zones first to populate initial_value
            let raw_crop_zones = [];
            // Merge digits and dials -> ONLY DIGITS for global variable now
            let all_zones = [...state.digits];

            all_zones.forEach(z => {
                // Calculate Scaled & Relativized Coordinates
                let res = calculateZoneCoordinates(z, off_x, off_y, scale_x, scale_y, w, h);

                // Apply Final Output Scaling
                if (use_scaling) {
                    res.x = Math.round(res.x * final_scale_x);
                    res.y = Math.round(res.y * final_scale_y);
                    res.w = Math.round(res.w * final_scale_x);
                    res.h = Math.round(res.h * final_scale_y);
                }

                raw_crop_zones.push(`[${res.x},${res.y},${res.x + res.w},${res.y + res.h}]`);
            });

            lines.push(`    initial_value: '"[${raw_crop_zones.join(',')}]"'`);
            lines.push(``); // Spacer

            lines.push(`esp32_camera_utils:`);
            lines.push(`  id: \${id_prefix}_camera_utils`);
            lines.push(`  camera_id: \${id_prefix}_espcam`);
            lines.push(`  # debug: true`);
            lines.push(`  ### zoom availale for OV2640, OV3660, OV5640, SC101IOT, SC030IOT from crop zones (explicit)`);

            if (state.roi) {
                // Explanatory Comments for Swapped Dims
                let comment_w = "# multiple of 8";
                let comment_h = "# multiple of 8";
                if (state.rotation === 90 || state.rotation === 270) {
                    comment_w += " (Visual Height)";
                    comment_h += " (Visual Width)";
                }

                // Bounds Check (Sensor Space)
                if (off_x + w > sensor_w) lines.push(`  # WARNING: ROI width exceeds sensor bounds!`);
                if (off_y + h > sensor_h) lines.push(`  # WARNING: ROI height exceeds sensor bounds!`);

                lines.push(`  camera_window:`);
                lines.push(`    offset_x: ${off_x} # multiple of 4`);
                lines.push(`    offset_y: ${off_y} # multiple of 4`);
                lines.push(`    width: ${w} ${comment_w} #Enforcement: 4:3 Aspect Ratio (W/H = 160/120)`);
                lines.push(`    height: ${h} ${comment_h}`);
            } else {
                lines.push(`  # No camera_window defined (Full Sensor or default)`);
            }

            lines.push(``);
            lines.push(`  enable_rotation: true`);
            lines.push(`  rotation: ${state.rotation} # 0, 90, 180, 270 (special case built-in "accelerated" for 90, 180, 270 )`);

            // Add Debug Comments at bottom
            lines.push(``);
            lines.push(`# --- Debug Info ---`);
            lines.push(`# Sensor: ${state.sensorRes.name}`);
            lines.push(`# Original Image: ${img_w}x${img_h}`);
            if (use_scaling) {
                let unscaled_out_w = (state.rotation % 180 === 0) ? w : h;
                let unscaled_out_h = (state.rotation % 180 === 0) ? h : w;
                lines.push(`# Output Scaling: Mapping ${unscaled_out_w}x${unscaled_out_h} (ROI) -> ${target_w}x${target_h}`);
            }
            if (anisotropic) lines.push(`# WARNING: Anisotropic scaling input detected!`);

            // Analog Dials Generation
            if (state.dials.length > 0) {
                lines.push(``);
                lines.push(`analog_reader: # DEV !`);
                lines.push(`  id: \${id_prefix}_analog_reader`);
                lines.push(`  camera_id: \${id_prefix}_espcam`);
                // lines.push(`  # validator: \${id_prefix}_analog_validator`);
                lines.push(`  debug: true`);
                lines.push(`  value_sensor:`);
                lines.push(`    name: "Analog Total"`);
                lines.push(`  update_interval: 60s`);
                lines.push(`  dials:`);

                state.dials.forEach((d, i) => {
                     // Calculate Scaled & Relativized Coordinates (Same logic as digits)
                    let res = calculateZoneCoordinates(d, off_x, off_y, scale_x, scale_y, w, h);

                    // Apply Final Output Scaling
                    if (use_scaling) {
                        res.x = Math.round(res.x * final_scale_x);
                        res.y = Math.round(res.y * final_scale_y);
                        res.w = Math.round(res.w * final_scale_x);
                        res.h = Math.round(res.h * final_scale_y);
                    }
                    
                    lines.push(`    - id: dial_${i+1}`);
                    lines.push(`      scale: 0.1`);
                    lines.push(`      crop_x: ${res.x}`);
                    lines.push(`      crop_y: ${res.y}`);
                    lines.push(`      crop_w: ${res.w}`);
                    lines.push(`      crop_h: ${res.h}`);
                    lines.push(`      min_angle: 0`);
                    lines.push(`      max_angle: 360`);
                    lines.push(`      min_value: 0`);
                    lines.push(`      max_value: 10`);
                });
            }

            ta.value = lines.join('\n');
        }

        // Interaction
        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (e.clientX - rect.left),
                y: (e.clientY - rect.top)
            };
        }

        function startDrawing(e) {
            if (!state.image) return;
            state.isDrawing = true;
            state.startPos = getMousePos(e);
        }

        function draw(e) {
            if (!state.isDrawing) return;
            const pos = getMousePos(e);
            const w = pos.x - state.startPos.x;
            const h = pos.y - state.startPos.y;

            updateCanvas(); // Clear old partial rect

            // Draw scratch rect
            let color = '#3498db'; // ROI
            if (state.mode === 'digits') color = '#2ecc71';
            if (state.mode === 'analog') color = '#f39c12';

            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);

            if (state.mode === 'analog') {
                // ctx.strokeStyle = '#f39c12'; // Consolidate color logic removed
                // Center-based Square
                let dist = Math.max(Math.abs(pos.x - state.startPos.x), Math.abs(pos.y - state.startPos.y));
                let cx = state.startPos.x;
                let cy = state.startPos.y;
                ctx.strokeRect(cx - dist, cy - dist, dist * 2, dist * 2);
            } else {
                ctx.strokeRect(state.startPos.x, state.startPos.y, w, h);
            }

            ctx.setLineDash([]);
        }

        function stopDrawing(e) {
            if (!state.isDrawing) return;
            state.isDrawing = false;
            const pos = getMousePos(e);

            // Normalize Rect
            let x, y, w, h;

            if (state.mode === 'analog') {
                // Center-based Square
                let dist = Math.max(Math.abs(pos.x - state.startPos.x), Math.abs(pos.y - state.startPos.y));
                let cx = state.startPos.x;
                let cy = state.startPos.y;
                x = cx - dist;
                y = cy - dist;
                w = dist * 2;
                h = dist * 2;
            } else {
                x = Math.min(state.startPos.x, pos.x);
                y = Math.min(state.startPos.y, pos.y);
                w = Math.abs(pos.x - state.startPos.x);
                h = Math.abs(pos.y - state.startPos.y);
            }

            // Snap/Min size
            if (w < 4 || h < 4) return;

            if (state.mode === 'roi') {
                state.roi = { x, y, w, h };
                state.digits = []; // Reset digits if ROI changes
                state.dials = [];
            } else if (state.mode === 'digits') {
                if (checkOutsideROI(x, y, w, h, 'Zone')) return;
                state.digits.push({ x: x, y: y, w: w, h: h });
            } else if (state.mode === 'analog') {
                if (checkOutsideROI(x, y, w, h, 'Dial')) return;
                state.dials.push({ x: x, y: y, w: w, h: h });
            }

            updateCanvas();
            generateOutput();
        }

        function resetCurrent() {
            if (state.mode === 'roi') state.roi = null;
            if (state.mode === 'digits') state.digits.pop(); // Undo last
            if (state.mode === 'analog') state.dials.pop(); // Undo last
            updateCanvas();
            generateOutput();
        }

        function resetAll() {
            state.roi = null;
            state.digits = [];
            state.dials = [];
            updateCanvas();
            generateOutput();
        }

        function copyOutput() {
            const copyText = document.getElementById("output");
            navigator.clipboard.writeText(copyText.value).then(() => {
                alert("Copied to clipboard");
            }).catch(err => {
                alert("Failed to copy. See console for details.");
                console.error('Failed to copy text: ', err);
            });
        }
        // Coordinate Mapping: Original (Sensor) -> Rotated (Canvas) - INVERSE
        function mapFromOriginal(ox, oy, ow, oh) {
            const W = state.image.width;
            const H = state.image.height;
            let x, y, w, h;

            // Rotated Dims (Canvas Dims)
            const RW = (state.rotation % 180 === 0) ? W : H;
            const RH = (state.rotation % 180 === 0) ? H : W;

            switch (state.rotation) {
                case 0:
                    x = ox; y = oy; w = ow; h = oh;
                    break;
                case 90:
                    // Inverse 90 CW
                    // x = RW - oy - oh
                    // y = ox
                    // w = oh
                    // h = ow
                    x = RW - oy - oh;
                    y = ox;
                    w = oh;
                    h = ow;
                    break;
                case 180:
                    // Inverse 180
                    // x = RW - ox - ow
                    // y = RH - oy - oh
                    x = RW - ox - ow;
                    y = RH - oy - oh;
                    w = ow;
                    h = oh;
                    break;
                case 270: // 90 CCW
                    // Inverse 270 (which is 90 CW from Rotated perspective)
                    // x = oy
                    // y = RH - ox - w (wait, h?)
                    // From mapToOrignial 270: ox = RH - (y+h). -> ox = RH - y - h -> y = RH - ox - h. Correct.
                    x = oy;
                    y = RH - ox - ow; // FIXED: Visual Y depends on Visual Height (Sensor Width)
                    w = oh;
                    h = ow;
                    break;
            }

            return { x, y, w, h };
        }

        function updateROIFromInput() {
            if (!state.image) return;
            // Inputs are SENSOR coordinates
            const off_x = parseInt(document.getElementById('manual_x').value) || 0;
            const off_y = parseInt(document.getElementById('manual_y').value) || 0;
            const w_in = parseInt(document.getElementById('manual_w').value) || 100;
            const h_in = parseInt(document.getElementById('manual_h').value) || 100;

            // 1. Unscale: Sensor -> Unrotated Image Space
            const img_w = state.image.width;
            const img_h = state.image.height;
            const sensor_w = state.sensorRes.w;
            const sensor_h = state.sensorRes.h;

            const scale_x = sensor_w / img_w;
            const scale_y = sensor_h / img_h;

            let ox = off_x / scale_x;
            let oy = off_y / scale_y;
            let ow = w_in / scale_x;
            let oh = h_in / scale_y;

            // 2. Unmap: Unrotated Image Space -> Rotated Visual Space
            const vis = mapFromOriginal(ox, oy, ow, oh);

            // 3. Set State (Visual)
            state.roi = {
                x: Math.round(vis.x),
                y: Math.round(vis.y),
                w: Math.round(vis.w),
                h: Math.round(vis.h)
            };

            state.isManualUpdate = true; // prevent loop
            updateCanvas();
            generateOutput(); // This will snap values and update inputs again, but that's okay (auto-correction)
            state.isManualUpdate = false;
        }


        setMode("roi");
    </script>
</body>

</html>